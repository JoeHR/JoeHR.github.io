(window.webpackJsonp=window.webpackJsonp||[]).push([[48],{636:function(v,_,t){"use strict";t.r(_);var r=t(21),e=Object(r.a)({},(function(){var v=this,_=v.$createElement,t=v._self._c||_;return t("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[t("h1",{attrs:{id:"javascript"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#javascript"}},[v._v("#")]),v._v(" javascript")]),v._v(" "),t("p",[v._v("::: info")]),v._v(" "),t("p",[v._v("设计原则（SOLID）是设计模式的指导理论，它可以帮助我们规避不良的软件设计。它指代的五个基本原则分别是：")]),v._v(" "),t("ul",[t("li",[v._v("单一功能原则 (Single Responsibility Principle)\n"),t("ul",[t("li",[v._v("一个程序只做一件事")]),v._v(" "),t("li",[v._v("如果功能过于复杂就拆分开，每个部分保持独立")])])]),v._v(" "),t("li",[v._v("开放封闭原则 (Open Closed Principle)\n"),t("ul",[t("li",[v._v("对扩展开放，对修改封闭")]),v._v(" "),t("li",[v._v("增加需求时，扩展新代码，而非修改已有的代码")])])]),v._v(" "),t("li",[v._v("里式替换原则 (Lishov Substitution Principle)\n"),t("ul",[t("li",[v._v("子类能覆盖父类")]),v._v(" "),t("li",[v._v("父类能出现的地方子类就能出现")])])]),v._v(" "),t("li",[v._v("接口隔离原则 (Interface Segregation Principle)\n"),t("ul",[t("li",[v._v("保持接口的单一独立")]),v._v(" "),t("li",[v._v("类似单一职责原则，这里更关注接口")])])]),v._v(" "),t("li",[v._v("依赖反转原则 (Dependency Inversion Principle)\n"),t("ul",[t("li",[v._v("面向接口编程，依赖于抽象而不依赖于具体")]),v._v(" "),t("li",[v._v("使用方只关注接口而不关注具体类的实现")])])])]),v._v(" "),t("p",[v._v('在 javascript 设计模式中，主要用到的设计模式基本都围绕 "单一功能" 和 "开放封闭" 这两个原则来展开')]),v._v(" "),t("p",[v._v(":::")]),v._v(" "),t("p",[t("strong",[v._v("设计模式的核心思想——封装变化")])]),v._v(" "),t("p",[v._v("设计模式出现的背景，是软件设计的复杂度日益飙升。软件设计越来越复杂的“罪魁祸首”，就是变化。")]),v._v(" "),t("p",[v._v("这一点相信大家不难理解——如果说我们写一个业务，这个业务是一潭死水，初始版本是 1.0，100 年后还是 1.0，不接受任何迭代和优化，那么这个业务几乎可以随便写。反正只要实现功能就行了，完全不需要考虑可维护性、可扩展性。")]),v._v(" "),t("p",[v._v("但在实际开发中，不发生变化的代码可以说是不存在的。我们能做的只有将这个变化造成的影响最小化 —— 将变与不变分离，确保变化的部分灵活、不变的部分稳定。")]),v._v(" "),t("p",[v._v("这个过程，就叫“封装变化”；这样的代码，就是我们所谓的“健壮”的代码，它可以经得起变化的考验。而设计模式出现的意义，就是帮我们写出这样的代码")]),v._v(" "),t("p",[t("strong",[v._v("设计模式的“术”")])]),v._v(" "),t("p",[v._v("所谓“术”，其实就是指二十年前 GOF 提出的最经典的 23 种设计模式。二十年前，四位程序员前辈（Erich Gamma, Richard Helm, Ralph Johnson & John Vlissides）通过编写《设计模式：可复用面向对象软件的基础》这本书，阐述了设计模式领域的开创性成果。在这本书中，将 23 种设计模式按照“创建型”、“行为型”和“结构型”进行划分：")]),v._v(" "),t("table",[t("tr",[t("td",{attrs:{rowspan:"23"}},[v._v("23种设计模式")]),v._v(" "),t("td",{attrs:{rowspan:"5"}},[v._v("\n          创建型\n          (封装创建对象过程中的变化,将创建对象的过程进行抽离)\n       ")]),v._v(" "),t("td",[v._v("单例模式")])]),v._v(" "),t("tr",[t("td",[v._v("原型模式")])]),v._v(" "),t("tr",[t("td",[v._v("构造器模式")])]),v._v(" "),t("tr",[t("td",[v._v("工厂模式")])]),v._v(" "),t("tr",[t("td",[v._v("抽象工厂模式")])]),v._v(" "),t("tr",[t("td",{attrs:{rowspan:"7"}},[v._v("\n          结构型\n          (封装对象之间组合方式的变化；灵活表达对象间的配合与依赖关系)\n       ")]),v._v(" "),t("td",[v._v("桥接模式")])]),v._v(" "),t("tr",[t("td",[v._v("外观模式")])]),v._v(" "),t("tr",[t("td",[v._v("组合模式")])]),v._v(" "),t("tr",[t("td",[v._v("装饰器模式")])]),v._v(" "),t("tr",[t("td",[v._v("适配器模式")])]),v._v(" "),t("tr",[t("td",[v._v("代理模式")])]),v._v(" "),t("tr",[t("td",[v._v("享元模式")])]),v._v(" "),t("tr",[t("td",{attrs:{rowspan:"11"}},[v._v("\n          行为型(将对象千变万化的行为进行抽离，\n          确保我们能够更安全、更方便的对行为进行更改)\n       ")]),v._v(" "),t("td",[v._v("迭代器模式")])]),v._v(" "),t("tr",[t("td",[v._v("解释器模式")])]),v._v(" "),t("tr",[t("td",[v._v("观察者模式")])]),v._v(" "),t("tr",[t("td",[v._v("中介者模式")])]),v._v(" "),t("tr",[t("td",[v._v("访问者模式")])]),v._v(" "),t("tr",[t("td",[v._v("状态模式")])]),v._v(" "),t("tr",[t("td",[v._v("备忘录模式")])]),v._v(" "),t("tr",[t("td",[v._v("策略模式")])]),v._v(" "),t("tr",[t("td",[v._v("模板方法模式")])]),v._v(" "),t("tr",[t("td",[v._v("职责链模式")])]),v._v(" "),t("tr",[t("td",[v._v("命令模式")])])]),v._v(" "),t("h2",{attrs:{id:"创建型-设计模式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#创建型-设计模式"}},[v._v("#")]),v._v(" 创建型-设计模式")]),v._v(" "),t("h3",{attrs:{id:"工厂模式-抽象工厂"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#工厂模式-抽象工厂"}},[v._v("#")]),v._v(" 工厂模式 & 抽象工厂")]),v._v(" "),t("blockquote",[t("p",[v._v("工厂模式其实就是将创建对象的过程单独封装，目的是抽象不同构造函数（类）之间的变与不变")])]),v._v(" "),t("p",[v._v("根据 抽象程度的不同可以分为： 简单工厂，工厂方法和抽象工厂")]),v._v(" "),t("p",[v._v("::: info")]),v._v(" "),t("p",[v._v("场景1：李雷 接到一个需求要做 一个员工信息录入系统，需要录入每个人的姓名，年龄和职位，今天提测，先把部门的500人录入系统看看功能。李雷心想，500个对象字面量，要死要死，还好我有构造函数。于是李雷写出了一个可以自动创建用户的 User 函数")]),v._v(" "),t("p",[v._v(":::")]),v._v(" "),t("pre",{staticStyle:{"user-select":"none"}},[v._v("  function User(name , age, career) {\n      this.name = name\n      this.age = age\n      this.career = career\n  }\n")]),v._v(" "),t("p",[v._v("实际上，李雷写的这个 User 函数就是一个构造器。接下来，就是让程序自动的读取数据库里面一行行的员工信息，然后把拿到的姓名、年龄等字段塞进 User函数，进行一个简单的调用")]),v._v(" "),t("pre",{staticStyle:{"user-select":"none"}},[v._v("  const user = new User(name,age,career)\n")]),v._v(" "),t("p",[v._v("像 User 这样当新建对象的内存被分配后，用来初始化该对象的特殊函数，就叫做构造器。在创建一个"),t("em",[v._v("user")]),v._v("过程中，很明显，变化的是每个 user 的姓名，年龄，工种这些值，这是每个 user 的 "),t("strong",[v._v("个性")]),v._v(",不变的是 每个 user 都具有  姓名、年龄 和工种 这些属性，这是每个 user 的 "),t("strong",[v._v("共性")])]),v._v(" "),t("p",[v._v("::: info")]),v._v(" "),t("p",[v._v("场景2：李雷的新需求，老板说这个系统录的信息也太简单了，程序员跟产品经理之间的区别一个简单的 carerr 字段怎么能说得清？我要去这个系统具备"),t("strong",[v._v("给不同工种分配职责说明")]),v._v("的功能。也就是所，要给每个工种的用户加上一个个性化的字段，来描述他们的工作内容")]),v._v(" "),t("p",[v._v(":::")])])}),[],!1,null,null,null);_.default=e.exports}}]);
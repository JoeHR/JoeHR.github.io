(window.webpackJsonp=window.webpackJsonp||[]).push([[52],{641:function(s,e,t){"use strict";t.r(e);var n=t(21),a=Object(n.a)({},(function(){var s=this,e=s.$createElement,t=s._self._c||e;return t("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[t("h2",{attrs:{id:"styled-jsx"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#styled-jsx"}},[s._v("#")]),s._v(" "),t("a",{attrs:{href:"https://github.com/zeit/styled-jsx",target:"_blank",rel:"noopener noreferrer"}},[s._v("styled-jsx"),t("OutboundLink")],1)]),s._v(" "),t("p",[s._v("zeit 的一系列产品从 now，到 next.js，我算是一个脑残粉。简洁好用是我对 zeit 的项目的印象。而且一套库自成系统，styled-jsx 和 next.js 完美兼容。")]),s._v(" "),t("h3",{attrs:{id:"_1-基础用法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-基础用法"}},[s._v("#")]),s._v(" 1. 基础用法")]),s._v(" "),t("p",[s._v("styled-jsx 概括第一印象就是 React css 的 vue 解决。\n"),t("code",[s._v("yarn add styled-jsx")]),s._v(" 安装后，不用"),t("code",[s._v("import")]),s._v("，而是一个babel插件，"),t("code",[s._v(".babelrc")]),s._v("配置：")]),s._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[s._v('{\n  "plugins": [\n    "styled-jsx/babel"\n  ]\n}\n复制代码\n')])])]),t("p",[s._v("然后就直接用了")]),s._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[s._v("render () {\n    return <div className='table'>\n        <div className='row'>\n            <div className='cell'>A0</div>\n            <div className='cell'>B0</div>\n        </div>\n        <style jsx>{`\n          .table {\n            margin: 10px;\n          }\n          .row {\n            border: 1px solid black;\n          }\n          .cell {\n            color: red;\n          }\n    `}</style>\n    </div>;\n}\n复制代码\n")])])]),t("ul",[t("li",[s._v("``的位置可以按喜好自定，样式总是作用于组件的所有元素")]),s._v(" "),t("li",[s._v("样式只作用于本组件，不影响全局也不影响子组件")]),s._v(" "),t("li",[s._v("实现方式大致是给组件内所有标签自动加上了一个独特"),t("code",[s._v("className")]),s._v(" 例如")])]),s._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[s._v("const App = () => (\n  <div>\n    <p>只有这个p会被上样式</p>\n    <style jsx>{`\n      p {\n        color: red;\n      }\n    `}</style>\n  </div>\n)\n复制代码\n")])])]),t("p",[s._v("会被转化成")]),s._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[s._v("import _JSXStyle from 'styled-jsx/style'\n\nconst App = () => (\n  <div className='jsx-123'>\n    <p className='jsx-123'>只有这个p会被上样式</p>\n    <_JSXStyle styleId='123' css={`p.jsx-123 {color: red;}`} />\n  </div>\n)\n复制代码\n")])])]),t("p",[s._v("从实现到原理，对比vue是不是非常像呢？如果你不喜欢将样式写在 render 里，styled-jsx 提供了一个 "),t("code",[s._v("css")]),s._v(" 的工具函数：")]),s._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[s._v("import css from 'styled-jsx/css'\n\nexport default () => (\n  <div>\n    <button>styled-jsx</button>\n    <style jsx>{button}</style>\n  </div>\n)\n\nconst button = css`button { color: hotpink; }`\n复制代码\n")])])]),t("p",[s._v("非常完美的css解决方案。 下面针对“选择标准”里提到的各个方面考察一下 styled-jsx")]),s._v(" "),t("h3",{attrs:{id:"_2-动态css"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-动态css"}},[s._v("#")]),s._v(" 2. 动态css")]),s._v(" "),t("p",[s._v("和 styled-components，Motion 等模板字符串的解决方案一样，动态css轻而易举")]),s._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[s._v("export default (props) => (\n  <div>\n    <button>styled-jsx</button>\n    <style jsx>{\n      `button { color: ${props.color}; }`\n    }</style>\n  </div>\n)\n复制代码\n")])])]),t("p",[s._v("同个组件里可以写无限个``标签，这里的最佳实践是将静态的css放一个标签，动态的放另一个，每次渲染时只有动态的重新计算和渲染")]),s._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[s._v("const Button = (props) => (\n  <button>\n     { props.children }\n     <style jsx>{`\n        button {\n          color: #999;\n          display: inline-block;\n          font-size: 2em;\n        }\n     `}</style>\n     <style jsx>{`\n        button {\n          padding: ${ 'large' in props ? '50' : '20' }px;\n          background: ${props.theme.background};\n        }\n     `}</style>\n  </button>\n)\n复制代码\n")])])]),t("p",[s._v("两点注意：")]),s._v(" "),t("ul",[t("li",[s._v("只有写在 render 函数里的style是动态的，所以动态css不能如第二例那样提取出来")]),s._v(" "),t("li",[s._v("原声解决方法的 style props的样式会覆盖 styled-jsx 的样式")])]),s._v(" "),t("h3",{attrs:{id:"_3-如何使用sass"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-如何使用sass"}},[s._v("#")]),s._v(" 3. 如何使用Sass")]),s._v(" "),t("p",[s._v("两个字，插件。")]),s._v(" "),t("ul",[t("li",[t("a",{attrs:{href:"https://github.com/giuseppeg/styled-jsx-plugin-sass",target:"_blank",rel:"noopener noreferrer"}},[s._v("styled-jsx-plugin-sass"),t("OutboundLink")],1)]),s._v(" "),t("li",[t("a",{attrs:{href:"https://github.com/giuseppeg/styled-jsx-plugin-postcss",target:"_blank",rel:"noopener noreferrer"}},[s._v("styled-jsx-plugin-postcss"),t("OutboundLink")],1)]),s._v(" "),t("li",[t("a",{attrs:{href:"https://github.com/giuseppeg/styled-jsx-plugin-stylelint",target:"_blank",rel:"noopener noreferrer"}},[s._v("styled-jsx-plugin-stylelint"),t("OutboundLink")],1)]),s._v(" "),t("li",[t("a",{attrs:{href:"https://github.com/erasmo-marin/styled-jsx-plugin-less",target:"_blank",rel:"noopener noreferrer"}},[s._v("styled-jsx-plugin-less"),t("OutboundLink")],1)]),s._v(" "),t("li",[t("a",{attrs:{href:"https://github.com/omardelarosa/styled-jsx-plugin-stylus",target:"_blank",rel:"noopener noreferrer"}},[s._v("styled-jsx-plugin-stylus"),t("OutboundLink")],1)])]),s._v(" "),t("p",[s._v("一应俱全。以Sass为例：")]),s._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[s._v("yarn add -D node-sass styled-jsx-plugin-sass\n复制代码\n")])])]),t("p",[t("code",[s._v(".babelrc")]),s._v("配置")]),s._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[s._v('{\n  "plugins": [\n    [\n      "styled-jsx/babel",\n      { "plugins": ["styled-jsx-plugin-sass"] }\n    ]\n  ]\n}\n复制代码\n')])])]),t("p",[s._v("即可使用Sass。")]),s._v(" "),t("h3",{attrs:{id:"_4-全局css"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4-全局css"}},[s._v("#")]),s._v(" 4. 全局css")]),s._v(" "),t("p",[s._v("如同 Vue 以 "),t("code",[s._v("scoped")]),s._v(" 为关键字，styled-jsx 以 "),t("code",[s._v("global")]),s._v(" 为关键字。")]),s._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[s._v("export default () => (\n  <div>\n    <style jsx global>{`\n      body {\n        background: red\n      }\n    `}</style>\n  </div>\n)\n复制代码\n")])])]),t("p",[s._v("全局样式注明 global 即可。")]),s._v(" "),t("p",[s._v("有极少情况（比如传一个全局类给三方库）需要使单个选择器全局化，语法类似 css-module")]),s._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[s._v("div :global(.react-select) {\n    color: red\n}\n复制代码\n")])])]),t("h3",{attrs:{id:"_5-三方ui库的支持"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_5-三方ui库的支持"}},[s._v("#")]),s._v(" 5. 三方UI库的支持")]),s._v(" "),t("p",[s._v("相对有点繁琐，思想是取得styled-jsx转化过后的类名，注入到三方库的className props里，这样即解决了支持，又保全了局部css，代码如下")]),s._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[s._v("import Link from 'react-router-dom' // 例子，给Link组件添加样式\n\nconst scoped = resolveScopedStyles(\n  <scope>\n    <style jsx>{'.link { color: green }'}</style>\n  </scope>\n)\n\nconst App = ({ children }) => (\n  <div>\n    {children}\n    <Link to=\"/about\" className={`link ${scoped.className}`}>\n      About\n    </Link>\n\n    {scoped.styles}\n  </div>\n);\n\nfunction resolveScopedStyles(scope) {\n  return {\n    className: scope.props.className, //就是被styled-jsx添加的独特className\n    styles: scope.props.children      //就是style，注入到App组件中\n  }\n}\n复制代码\n")])])]),t("p",[s._v("当然，如果你不介意局部不局部，可以使用上面提到的"),t("code",[s._v(":global()")]),s._v(" 语法")]),s._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[s._v("// 比如Form组件有类名form-item\nexport default () => (\n  <div>\n    <Form />\n    <style jsx>{`\n      div > :global(.form-item) {\n        color: red\n      }\n    `}</style>\n  </div>\n)\n复制代码\n")])])]),t("h3",{attrs:{id:"_6-语法高亮与补完"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_6-语法高亮与补完"}},[s._v("#")]),s._v(" 6. 语法高亮与补完")]),s._v(" "),t("p",[s._v("我使用VSCode：")]),s._v(" "),t("ul",[t("li",[t("a",{attrs:{href:"https://marketplace.visualstudio.com/items?itemName=blanu.vscode-styled-jsx",target:"_blank",rel:"noopener noreferrer"}},[s._v("语法高亮"),t("OutboundLink")],1)]),s._v(" "),t("li",[t("a",{attrs:{href:"https://marketplace.visualstudio.com/items?itemName=AndrewRazumovsky.vscode-styled-jsx-languageserver",target:"_blank",rel:"noopener noreferrer"}},[s._v("自动补完"),t("OutboundLink")],1)])]),s._v(" "),t("p",[s._v("其他的见 github 上 readme。")]),s._v(" "),t("h3",{attrs:{id:"_7-大小-性能"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_7-大小-性能"}},[s._v("#")]),s._v(" 7. 大小？性能？")]),s._v(" "),t("ul",[t("li",[s._v("可使用所有css语法")]),s._v(" "),t("li",[s._v("3kb的gzip大小")]),s._v(" "),t("li",[s._v("浏览器的prefix自动加了")]),s._v(" "),t("li",[s._v("有source-map 支持，方便debug")]),s._v(" "),t("li",[s._v("据作者说性能也很高")])]),s._v(" "),t("h3",{attrs:{id:"_8-style-jsx-vs-styled-components"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_8-style-jsx-vs-styled-components"}},[s._v("#")]),s._v(" 8. style-jsx vs styled-components")]),s._v(" "),t("p",[s._v("谢谢ziven27提议，我试着说说和现在最流行的 styled-components 库的区别。（方便讨论，“前者”代指style-jsx，“后者”代指style-components）")]),s._v(" "),t("ul",[t("li",[s._v("最大区别在于前者样式作用于整个组件，后者的样式只作用于所包裹的元素。打个比方就如同vue和inline css的区别。但其实只要使用sass的"),t("code",[s._v("&")]),s._v("嵌套，后者也是可以包裹组件最外层元素然后将其他元素样式统统写入的。虽然感觉不是后者的初衷。")]),s._v(" "),t("li",[s._v("后者与提供"),t("code",[s._v("className")]),s._v(" props的三方库完美整合（比前者简洁太多）：")])]),s._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[s._v("const RedButton = styled(Button)`background: red;`\n复制代码\n")])])]),t("p",[s._v("但对不提供"),t("code",[s._v("className")]),s._v(" props的三方库一筹莫展（当然这种情况不太出现）。")]),s._v(" "),t("ul",[t("li",[s._v("后者由于使用了HOC模式，与其他所有HOC一样要处理ref的问题（包裹层的ref不同于原本元素的ref），多一事。")]),s._v(" "),t("li",[s._v("个人觉得前者的规则简洁明了（css怎么写就怎么写），后者有不少“魔术”的部分（比如props，theme），也引入了很多高级用法如"),t("code",[s._v(".extends")]),s._v(" 样式继承以及"),t("code",[s._v(".attrs")]),s._v("封装公用props。")])]),s._v(" "),t("p",[s._v("这里提到一个话题，到底是“魔术”好呢，还是朴实好呢？举个例子，比如theme（主题）：")]),s._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[s._v("// styled-components 使用Provider提供主题，主题可以是样式，也可以是函数\nconst Button = styled.button`\n  color: ${props => props.theme.fg};\n  border: 2px solid ${props => props.theme.fg};\n  background: ${props => props.theme.bg};\n\n  font-size: 1em;\n  margin: 1em;\n  padding: 0.25em 1em;\n  border-radius: 3px;\n`;\n\n// 主题的样式\nconst theme = {\n  fg: 'palevioletred',\n  bg: 'white'\n};\n\n// 换前景色和背景色的函数\nconst invertTheme = ({ fg, bg }) => ({\n  fg: bg,\n  bg: fg\n});\n\nrender(\n  <ThemeProvider theme={theme}>\n    <div>\n      <Button>Default Theme</Button>\n\n      <ThemeProvider theme={invertTheme}>\n        <Button>Inverted Theme</Button>\n      </ThemeProvider>\n    </div>\n  </ThemeProvider>\n);\n复制代码\n")])])]),t("p",[s._v("甚至还提供了一个HOC，在styled-components外使用theme")]),s._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[s._v("import { withTheme } from 'styled-components'\n复制代码\n")])])]),t("p",[s._v("强大不强大？对比之下，styled-jsx没有任何与theme相关的api，只是朴朴实实地靠props传递达成主题：")]),s._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[s._v("// styled-jsx\nimport { colors, spacing } from '../theme'\nimport { invertColor } from '../theme/utils'\n\nconst Button = ({ children }) => (\n  <button>\n     { children }\n     <style jsx>{`\n        button {\n          padding: ${ spacing.medium };\n          background: ${ colors.primary };\n          color: ${ invertColor(colors.primary) };\n        }\n     `}</style>\n  </button>\n)\n复制代码\n")])])]),t("p",[s._v("这个问题要看应用场景和个人喜好吧，我属于不喜欢过多“魔术”，爱简单api（哪怕多点代码）的那派。大家有啥想法和指正，多多留言。")]),s._v(" "),t("h2",{attrs:{id:"最后"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#最后"}},[s._v("#")]),s._v(" 最后")]),s._v(" "),t("p",[s._v("有2个细小缺点")]),s._v(" "),t("ol",[t("li",[s._v("和CRA整合时，css-in-js 的解决方式不会热加载，每次都刷新页面。")]),s._v(" "),t("li",[s._v("和CRA整合时，由于是babel插件，需要eject或者使用"),t("a",{attrs:{href:"https://github.com/timarney/react-app-rewired",target:"_blank",rel:"noopener noreferrer"}},[t("code",[s._v("react-app-rewired")]),t("OutboundLink")],1),s._v("来加入 babel plugin 的设置。")])]),s._v(" "),t("p",[s._v("之前有小伙伴留言表示有坑（谢谢，看到这样的留言觉得写blog的决定太对了）")]),s._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[s._v("同样觉得styled-jsx非常好，最近一直在用。\n但目前还是有些不成熟的地方，主要是：\n1、局部样式无法支持第三方组件标签，只能支持普通html标签\n2、对stylelint缺乏支持，官方出的stylelint插件只是一个demo。在vscode中用stylelint插件时也是有很大的坑。\n复制代码\n")])])]),t("Vssue",{attrs:{title:"Vssue Demo"}})],1)}),[],!1,null,null,null);e.default=a.exports}}]);
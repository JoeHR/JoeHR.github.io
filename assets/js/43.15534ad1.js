(window.webpackJsonp=window.webpackJsonp||[]).push([[43],{629:function(t,e,l){"use strict";l.r(e);var v=l(21),_=Object(v.a)({},(function(){var t=this,e=t.$createElement,l=t._self._c||e;return l("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[l("h2",{attrs:{id:"怎么实现大型文件上传"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#怎么实现大型文件上传"}},[t._v("#")]),t._v(" 怎么实现大型文件上传？")]),t._v(" "),l("ul",[l("li",[l("p",[t._v("分片上传（chunked upload）\n将大文件拆分成小的文件块（chunk）,然后通过多个并行的请求依次上传这些文件块。服务器接收到每个文件块后进行存储，最后合并所有文件块以还原原始文件。这种方法可以降低单个请求的负载，并允许在网络中断或上传失败时可以从断点续传。")])]),t._v(" "),l("li",[l("p",[t._v("流式上传（streaming upload）\n客户端使用流方式逐步读取文件的内容，并将数据流通过 post 请求发送给服务器。服务器端能够逐步接受并处理这些数据流，而无需等待完整的文件上传完成。这种方法适用于较大的文件，减少了内存占用和传输延迟。")])]),t._v(" "),l("li",[l("p",[t._v("使用专门的文件上传服务\n有一些第三方服务可供使用，例如文件传输协议（如 FTP、SFTP）；云存储服务（如Amazon S3、Google Cloud Storage等）它们提供了更方便的文件上传和下载功能，并提供了API，允许客户端直接将文件上传到云存储服务，而无需自己实现上传逻辑；这些服务通常提供了高可靠性、可扩展性和安全性，并且针对大文件上传进行了优化。")])]),t._v(" "),l("li",[l("p",[t._v("压缩文件上传\n如果可能，可以在客户端先对文件进行压缩，然后再进行上传。压缩后的文件大小更小，可以减少上传时间和网络带宽消耗。")])]),t._v(" "),l("li",[l("p",[t._v("并发上传\n通过多个并行的请求同时上传文件的不同部分，以加快整个上传过程。这需要服务器端支持并发上传并正确处理分片或部分文件的合并。")])]),t._v(" "),l("li",[l("p",[t._v("断点续传\n记录上传进度和状态，以便在网络中断货上传失败后能够从上次中断的位置继续上传。可以使用客户端或服务器端的断点续传机制来实现。")])])]),t._v(" "),l("div",{staticClass:"custom-block tip"},[l("p",{staticClass:"custom-block-title"},[t._v("TIP")]),t._v(" "),l("p",[t._v("补充知识点")])]),t._v(" "),l("p",[t._v("::: tabs")]),t._v(" "),l("p",[t._v("@tab 谁负责资源分片？谁负责资源整合？")]),t._v(" "),l("p",[t._v("前端负责分片，后端负责整合。")]),t._v(" "),l("p",[t._v("@tab 前端该如何进行分片?")]),t._v(" "),l("p",[t._v("1、获取到选择上传的文件对象File")]),t._v(" "),l("p",[t._v("2、通过File.prototype.slice 方法 或者 Blob.prototype.slice (Blob.prototype.slice === File.prototype.slice)方法 实现对文件资源的分片.")]),t._v(" "),l("p",[t._v("@tab 服务端怎么知道什么时候要整合资源?如何保障资源整合的有序性？")]),t._v(" "),l("p",[t._v("由于前端会将资源分片，然后单独发送请求，也就是说，原来1个文件对应1个上传请求，现在可能会变成1个文件对应 n 个上传请求，所以前端可以基于 Promise.all 来将这多个接口整合，上传完成在发送一个合并的请求，通知服务端进行合并。\n合并时可通过 nodejs中的 读写流 （readStream/writeStream）将所有切片的流通过 管道（pipe）输入最终文件的流中。")]),t._v(" "),l("p",[t._v("在发送请求资源时，前端会定好每个文件对应的序号，并将当前分片、序号以及文件hash 等信息一起发送给服务端，服务端在进行合并时，通过序号进行依次合并即可。")]),t._v(" "),l("p",[t._v("@tab 如果某个分片的上传请求失败了，怎么办？")]),t._v(" "),l("p",[t._v("一旦服务端某个上传请求失败，会返回当前分片失败的信息，其中会包含文件名称，文件hash、分片大小以及分片序号等，前端拿到这些信息后可以进行重传，同时考虑此时是否需要将 Promise.all 替换为 Promise.allSettled 更方便。")])])}),[],!1,null,null,null);e.default=_.exports}}]);
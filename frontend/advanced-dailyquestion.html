<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>每日一道面试题 | 个人主页</title>
    <meta name="generator" content="VuePress 1.9.9">
    <link rel="icon" href="/img/logo.ico">
    <link rel="apple-touch-icon" href="/img/logo.png">
    <meta name="description" content="rh的博客">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0;">
    
    <link rel="preload" href="/assets/css/0.styles.74a02103.css" as="style"><link rel="preload" href="/assets/js/app.f8839a88.js" as="script"><link rel="preload" href="/assets/js/2.8d06e467.js" as="script"><link rel="preload" href="/assets/js/8.bda61152.js" as="script"><link rel="prefetch" href="/assets/js/10.75500dcd.js"><link rel="prefetch" href="/assets/js/11.592669c1.js"><link rel="prefetch" href="/assets/js/12.a9094538.js"><link rel="prefetch" href="/assets/js/13.2cf414ec.js"><link rel="prefetch" href="/assets/js/14.d2737ceb.js"><link rel="prefetch" href="/assets/js/15.8eb8f805.js"><link rel="prefetch" href="/assets/js/16.820d5c80.js"><link rel="prefetch" href="/assets/js/17.801ecbcc.js"><link rel="prefetch" href="/assets/js/18.b2f69842.js"><link rel="prefetch" href="/assets/js/19.15396bbe.js"><link rel="prefetch" href="/assets/js/20.233b2644.js"><link rel="prefetch" href="/assets/js/21.858bfdd0.js"><link rel="prefetch" href="/assets/js/22.38ba5211.js"><link rel="prefetch" href="/assets/js/23.58fbdc70.js"><link rel="prefetch" href="/assets/js/24.15131ce6.js"><link rel="prefetch" href="/assets/js/25.7bce4e07.js"><link rel="prefetch" href="/assets/js/26.b37e74b8.js"><link rel="prefetch" href="/assets/js/27.64d94c4d.js"><link rel="prefetch" href="/assets/js/28.c78dfbd6.js"><link rel="prefetch" href="/assets/js/29.b576a40d.js"><link rel="prefetch" href="/assets/js/3.f9317427.js"><link rel="prefetch" href="/assets/js/30.29554d88.js"><link rel="prefetch" href="/assets/js/31.9af67186.js"><link rel="prefetch" href="/assets/js/32.d380b09a.js"><link rel="prefetch" href="/assets/js/33.eb0839b0.js"><link rel="prefetch" href="/assets/js/34.62b518b9.js"><link rel="prefetch" href="/assets/js/35.429a5bce.js"><link rel="prefetch" href="/assets/js/36.43c4d349.js"><link rel="prefetch" href="/assets/js/37.d6b42aa3.js"><link rel="prefetch" href="/assets/js/38.a7eec5a0.js"><link rel="prefetch" href="/assets/js/39.2f5a06ea.js"><link rel="prefetch" href="/assets/js/4.63a5e966.js"><link rel="prefetch" href="/assets/js/40.dc834d41.js"><link rel="prefetch" href="/assets/js/41.fcc4e1e8.js"><link rel="prefetch" href="/assets/js/42.e57f8aa8.js"><link rel="prefetch" href="/assets/js/43.15534ad1.js"><link rel="prefetch" href="/assets/js/44.eb90d815.js"><link rel="prefetch" href="/assets/js/45.6e206fc8.js"><link rel="prefetch" href="/assets/js/46.285350f5.js"><link rel="prefetch" href="/assets/js/47.cde65c12.js"><link rel="prefetch" href="/assets/js/48.1c870c67.js"><link rel="prefetch" href="/assets/js/49.2b6f4336.js"><link rel="prefetch" href="/assets/js/5.2c45f22c.js"><link rel="prefetch" href="/assets/js/50.1a667582.js"><link rel="prefetch" href="/assets/js/51.600bc042.js"><link rel="prefetch" href="/assets/js/52.2e105d94.js"><link rel="prefetch" href="/assets/js/53.fa0284c4.js"><link rel="prefetch" href="/assets/js/54.0b748f22.js"><link rel="prefetch" href="/assets/js/55.ee05dee1.js"><link rel="prefetch" href="/assets/js/56.21abdcc3.js"><link rel="prefetch" href="/assets/js/57.26ddbf76.js"><link rel="prefetch" href="/assets/js/58.91fd9800.js"><link rel="prefetch" href="/assets/js/59.6022db72.js"><link rel="prefetch" href="/assets/js/6.e9b45abe.js"><link rel="prefetch" href="/assets/js/60.1f2889ae.js"><link rel="prefetch" href="/assets/js/61.46040c7d.js"><link rel="prefetch" href="/assets/js/62.af7e9fcd.js"><link rel="prefetch" href="/assets/js/63.2fb355ca.js"><link rel="prefetch" href="/assets/js/64.99a87693.js"><link rel="prefetch" href="/assets/js/65.005ae6f4.js"><link rel="prefetch" href="/assets/js/66.12940877.js"><link rel="prefetch" href="/assets/js/67.b4a93190.js"><link rel="prefetch" href="/assets/js/68.c8d9d13c.js"><link rel="prefetch" href="/assets/js/69.158d7968.js"><link rel="prefetch" href="/assets/js/7.bbffe35f.js"><link rel="prefetch" href="/assets/js/70.4e4a3ae3.js"><link rel="prefetch" href="/assets/js/71.487c7568.js"><link rel="prefetch" href="/assets/js/72.e2a65bcb.js"><link rel="prefetch" href="/assets/js/9.f87a0e7d.js">
    <link rel="stylesheet" href="/assets/css/0.styles.74a02103.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><img src="/img/logo.png" alt="个人主页" class="logo"> <span class="site-name can-hide">个人主页</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">
  主页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="博客文章" class="dropdown-title"><span class="title">博客文章</span> <span class="arrow down"></span></button> <button type="button" aria-label="博客文章" class="mobile-dropdown-title"><span class="title">博客文章</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/test/" class="nav-link">
  测试
</a></li><li class="dropdown-item"><!----> <a href="/frontend/" class="nav-link router-link-active">
  前端
</a></li><li class="dropdown-item"><!----> <a href="/linux/" class="nav-link">
  linux
</a></li><li class="dropdown-item"><!----> <a href="/other/" class="nav-link">
  杂文
</a></li><li class="dropdown-item"><!----> <a href="/node/" class="nav-link">
  Node
</a></li><li class="dropdown-item"><!----> <a href="/python/" class="nav-link">
  Python
</a></li></ul></div></div><div class="nav-item"><a href="/readlog.html" class="nav-link">
  阅读日志
</a></div><div class="nav-item"><a href="/about/" class="nav-link">
  关于
</a></div> <a href="https://github.com/JoeHR/vuePress-blog" target="_blank" rel="noopener noreferrer" class="repo-link">
    Github
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">
  主页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="博客文章" class="dropdown-title"><span class="title">博客文章</span> <span class="arrow down"></span></button> <button type="button" aria-label="博客文章" class="mobile-dropdown-title"><span class="title">博客文章</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/test/" class="nav-link">
  测试
</a></li><li class="dropdown-item"><!----> <a href="/frontend/" class="nav-link router-link-active">
  前端
</a></li><li class="dropdown-item"><!----> <a href="/linux/" class="nav-link">
  linux
</a></li><li class="dropdown-item"><!----> <a href="/other/" class="nav-link">
  杂文
</a></li><li class="dropdown-item"><!----> <a href="/node/" class="nav-link">
  Node
</a></li><li class="dropdown-item"><!----> <a href="/python/" class="nav-link">
  Python
</a></li></ul></div></div><div class="nav-item"><a href="/readlog.html" class="nav-link">
  阅读日志
</a></div><div class="nav-item"><a href="/about/" class="nav-link">
  关于
</a></div> <a href="https://github.com/JoeHR/vuePress-blog" target="_blank" rel="noopener noreferrer" class="repo-link">
    Github
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>javascript</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>css</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>React学习</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Vue学习</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>工具</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>进阶</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/frontend/advanced-单例模式.html" class="sidebar-link">单例模式</a></li><li><a href="/frontend/advanced-装饰器模式.html" class="sidebar-link">装饰器模式</a></li><li><a href="/frontend/advanced-浏览器事件.html" class="sidebar-link">浏览器事件</a></li><li><a href="/frontend/advanced-虚拟Dom.html" class="sidebar-link">虚拟DOM简析</a></li><li><a href="/frontend/advanced-call,apply以及bind的使用与区别.html" class="sidebar-link">call,apply及bind得使用与区别</a></li><li><a href="/frontend/advanced-性能.html" class="sidebar-link">性能检测及加载优化</a></li><li><a href="/frontend/advanced-函数妙用.html" class="sidebar-link">高级函数</a></li><li><a href="/frontend/advanced-防篡改对象.html" class="sidebar-link">防篡改对象</a></li><li><a href="/frontend/advanced-前端监控.html" class="sidebar-link">监控</a></li><li><a href="/frontend/advanced-前端埋点.html" class="sidebar-link">前端监控与埋点</a></li><li><a href="/frontend/advanced-dailyquestion.html" aria-current="page" class="active sidebar-link">面试题</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/frontend/advanced-dailyquestion.html#第一题-写-react-vue-项目时为什么要在列表组件中写-key-其作用是什么" class="sidebar-link">第一题：写 React / Vue 项目时为什么要在列表组件中写 key，其作用是什么</a></li><li class="sidebar-sub-header"><a href="/frontend/advanced-dailyquestion.html#第二题-1-2-3-map-parseint-what-why" class="sidebar-link">第二题：['1', '2', '3'].map(parseInt) what &amp; why ?</a></li><li class="sidebar-sub-header"><a href="/frontend/advanced-dailyquestion.html#第三题-什么是防抖和节流-有什么区别-如何实现" class="sidebar-link">第三题：什么是防抖和节流？有什么区别？如何实现？</a></li><li class="sidebar-sub-header"><a href="/frontend/advanced-dailyquestion.html#第四题、javascript内存机制之问-数据是如何存储的" class="sidebar-link">第四题、JavaScript内存机制之问——数据是如何存储的？</a></li><li class="sidebar-sub-header"><a href="/frontend/advanced-dailyquestion.html#第五题、v8-引擎如何进行垃圾内存的回收" class="sidebar-link">第五题、V8 引擎如何进行垃圾内存的回收</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/frontend/advanced-dailyquestion.html#v8-内存限制" class="sidebar-link">V8 内存限制</a></li><li class="sidebar-sub-header"><a href="/frontend/advanced-dailyquestion.html#新生代内存的回收" class="sidebar-link">新生代内存的回收</a></li><li class="sidebar-sub-header"><a href="/frontend/advanced-dailyquestion.html#老生代内存堆的回收" class="sidebar-link">老生代内存堆的回收</a></li><li class="sidebar-sub-header"><a href="/frontend/advanced-dailyquestion.html#增量标记" class="sidebar-link">增量标记</a></li></ul></li><li class="sidebar-sub-header"><a href="/frontend/advanced-dailyquestion.html#第六题-虚拟dom的优劣如何" class="sidebar-link">第六题 虚拟DOM的优劣如何</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/frontend/advanced-dailyquestion.html#何为虚拟dom" class="sidebar-link">何为虚拟Dom</a></li><li class="sidebar-sub-header"><a href="/frontend/advanced-dailyquestion.html#为什么dom-渲染慢" class="sidebar-link">为什么DOM 渲染慢？</a></li><li class="sidebar-sub-header"><a href="/frontend/advanced-dailyquestion.html#为什么我们要使用虚拟dom" class="sidebar-link">为什么我们要使用虚拟DOM</a></li></ul></li><li class="sidebar-sub-header"><a href="/frontend/advanced-dailyquestion.html#第七题、什么是渲染函数-举个例子" class="sidebar-link">第七题、什么是渲染函数？举个例子</a></li><li class="sidebar-sub-header"><a href="/frontend/advanced-dailyquestion.html#第八题、在大型-vue-程序中管理状态的推荐方法是什么-为什么" class="sidebar-link">第八题、在大型 Vue 程序中管理状态的推荐方法是什么？为什么？</a></li><li class="sidebar-sub-header"><a href="/frontend/advanced-dailyquestion.html#第九题、vue-react路由传参的三种基本方式" class="sidebar-link">第九题、vue，react路由传参的三种基本方式</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/frontend/advanced-dailyquestion.html#vue-路由传参的三种方式" class="sidebar-link">vue 路由传参的三种方式</a></li><li class="sidebar-sub-header"><a href="/frontend/advanced-dailyquestion.html#react-router-页面传值的三种方法" class="sidebar-link">React  Router 页面传值的三种方法</a></li></ul></li><li class="sidebar-sub-header"><a href="/frontend/advanced-dailyquestion.html#第十题、简单介绍下webpack的工作原理" class="sidebar-link">第十题、简单介绍下webpack的工作原理</a></li><li class="sidebar-sub-header"><a href="/frontend/advanced-dailyquestion.html#第十一题、vue-中的-computed-和-watch-的区别在哪里" class="sidebar-link">第十一题、Vue 中的 computed 和 watch 的区别在哪里</a></li><li class="sidebar-sub-header"><a href="/frontend/advanced-dailyquestion.html#第十二题、script标签中defer和async的区别是什么" class="sidebar-link">第十二题、script标签中defer和async的区别是什么？</a></li><li class="sidebar-sub-header"><a href="/frontend/advanced-dailyquestion.html#第十三题、js数据类型之问-概念篇" class="sidebar-link">第十三题、JS数据类型之问-概念篇</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/frontend/advanced-dailyquestion.html#_1、js原始数据类型有哪些-引用数据类型有哪些" class="sidebar-link">1、JS原始数据类型有哪些？引用数据类型有哪些？</a></li><li class="sidebar-sub-header"><a href="/frontend/advanced-dailyquestion.html#_2、说出下面运行的结果-解释原因" class="sidebar-link">2、说出下面运行的结果，解释原因</a></li><li class="sidebar-sub-header"><a href="/frontend/advanced-dailyquestion.html#_3、null-是对象吗-为什么" class="sidebar-link">3、null 是对象吗？为什么？</a></li><li class="sidebar-sub-header"><a href="/frontend/advanced-dailyquestion.html#_4、-1-tostring-为什么可以调用" class="sidebar-link">4、'1'.toString() 为什么可以调用</a></li><li class="sidebar-sub-header"><a href="/frontend/advanced-dailyquestion.html#_5、0-1-0-2-为什么不等于0-3" class="sidebar-link">5、0.1+0.2 为什么不等于0.3？</a></li><li class="sidebar-sub-header"><a href="/frontend/advanced-dailyquestion.html#_6、如何理解-bigint" class="sidebar-link">6、如何理解 BigInt ?</a></li></ul></li><li class="sidebar-sub-header"><a href="/frontend/advanced-dailyquestion.html#第十四题、能不能说一说浏览器缓存" class="sidebar-link">第十四题、能不能说一说浏览器缓存</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/frontend/advanced-dailyquestion.html#强缓存" class="sidebar-link">强缓存</a></li><li class="sidebar-sub-header"><a href="/frontend/advanced-dailyquestion.html#协商缓存" class="sidebar-link">协商缓存</a></li><li class="sidebar-sub-header"><a href="/frontend/advanced-dailyquestion.html#缓存位置" class="sidebar-link">缓存位置</a></li><li class="sidebar-sub-header"><a href="/frontend/advanced-dailyquestion.html#service-worker" class="sidebar-link">Service Worker</a></li><li class="sidebar-sub-header"><a href="/frontend/advanced-dailyquestion.html#memory-cache-和-disk-cache" class="sidebar-link">Memory Cache 和 Disk Cache</a></li><li class="sidebar-sub-header"><a href="/frontend/advanced-dailyquestion.html#push-cache" class="sidebar-link">Push Cache</a></li><li class="sidebar-sub-header"><a href="/frontend/advanced-dailyquestion.html#总结" class="sidebar-link">总结</a></li></ul></li><li class="sidebar-sub-header"><a href="/frontend/advanced-dailyquestion.html#第十五题、js数据类型之问-检测篇" class="sidebar-link">第十五题、JS数据类型之问--检测篇</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/frontend/advanced-dailyquestion.html#_1、typpeof-是否能正确判断类型" class="sidebar-link">1、typpeof 是否能正确判断类型？</a></li><li class="sidebar-sub-header"><a href="/frontend/advanced-dailyquestion.html#_2、instanceof能否判断基本数据类型" class="sidebar-link">2、instanceof能否判断基本数据类型？</a></li><li class="sidebar-sub-header"><a href="/frontend/advanced-dailyquestion.html#_3-能不能手动实现一下instanceof的功能" class="sidebar-link">3. 能不能手动实现一下instanceof的功能？</a></li><li class="sidebar-sub-header"><a href="/frontend/advanced-dailyquestion.html#_4、object-is和-的区别" class="sidebar-link">4、Object.is和===的区别？</a></li></ul></li><li class="sidebar-sub-header"><a href="/frontend/advanced-dailyquestion.html#第十六题、js数据类型之问-转换篇" class="sidebar-link">第十六题、JS数据类型之问--转换篇</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/frontend/advanced-dailyquestion.html#_1、-结果是什么-为什么" class="sidebar-link">1、[] == ![] 结果是什么？为什么？</a></li><li class="sidebar-sub-header"><a href="/frontend/advanced-dailyquestion.html#_2、js-中类型转换有哪几种" class="sidebar-link">2、js 中类型转换有哪几种？</a></li><li class="sidebar-sub-header"><a href="/frontend/advanced-dailyquestion.html#_3、-和-有什么区别" class="sidebar-link">3、== 和 === 有什么区别？</a></li><li class="sidebar-sub-header"><a href="/frontend/advanced-dailyquestion.html#_4、对象转原始类型是根据什么流程运行的" class="sidebar-link">4、对象转原始类型是根据什么流程运行的</a></li><li class="sidebar-sub-header"><a href="/frontend/advanced-dailyquestion.html#_5、如何让-if-a-1-a-2-条件成立" class="sidebar-link">5、如何让 if(a==1&amp;&amp;a==2) 条件成立</a></li></ul></li><li class="sidebar-sub-header"><a href="/frontend/advanced-dailyquestion.html#第十七题-var-为什么会被let-取代" class="sidebar-link">第十七题：var 为什么会被let 取代</a></li><li class="sidebar-sub-header"><a href="/frontend/advanced-dailyquestion.html#第十八题、谈谈你对闭包的理解" class="sidebar-link">第十八题、谈谈你对闭包的理解</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/frontend/advanced-dailyquestion.html#什么时闭包" class="sidebar-link">什么时闭包？</a></li><li class="sidebar-sub-header"><a href="/frontend/advanced-dailyquestion.html#闭包产生的原因" class="sidebar-link">闭包产生的原因</a></li><li class="sidebar-sub-header"><a href="/frontend/advanced-dailyquestion.html#闭包有哪些表现形式" class="sidebar-link">闭包有哪些表现形式</a></li><li class="sidebar-sub-header"><a href="/frontend/advanced-dailyquestion.html#如何解决下面的循环输出问题" class="sidebar-link">如何解决下面的循环输出问题？</a></li></ul></li><li class="sidebar-sub-header"><a href="/frontend/advanced-dailyquestion.html#第十九题、实现一个-storage" class="sidebar-link">第十九题、实现一个 Storage</a></li><li class="sidebar-sub-header"><a href="/frontend/advanced-dailyquestion.html#第二十题、实现一个全局的模态框" class="sidebar-link">第二十题、实现一个全局的模态框</a></li><li class="sidebar-sub-header"><a href="/frontend/advanced-dailyquestion.html#第二十一题-下面哪些值是假值" class="sidebar-link">第二十一题：下面哪些值是假值</a></li><li class="sidebar-sub-header"><a href="/frontend/advanced-dailyquestion.html#第二十二题、-yield-和-generator" class="sidebar-link">第二十二题、 yield 和 generator</a></li><li class="sidebar-sub-header"><a href="/frontend/advanced-dailyquestion.html#第二十三题、双向绑定和vuex-是否冲突" class="sidebar-link">第二十三题、双向绑定和vuex 是否冲突</a></li><li class="sidebar-sub-header"><a href="/frontend/advanced-dailyquestion.html#第二十四题、关于const-和let-声明的变量为什么不在-window-上。" class="sidebar-link">第二十四题、关于const 和let 声明的变量为什么不在 window 上。</a></li></ul></li><li><a href="/frontend/advanced-web前端面试题.html" class="sidebar-link">刷面试</a></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>性能</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>面试题</span> <span class="arrow right"></span></p> <!----></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="每日一道面试题"><a href="#每日一道面试题" class="header-anchor">#</a> 每日一道面试题</h1> <h2 id="第一题-写-react-vue-项目时为什么要在列表组件中写-key-其作用是什么"><a href="#第一题-写-react-vue-项目时为什么要在列表组件中写-key-其作用是什么" class="header-anchor">#</a> 第一题：写 React / Vue 项目时为什么要在列表组件中写 key，其作用是什么</h2> <p>vue 和 react 都是采用 diff 算法来对比新旧虚拟节点，从而更新节点。在 vue 的 diff 函数中（建议先了解一下 diff 算法过程）。
在交叉对比中，当新节点跟旧节点<code>头尾交叉对比</code>没有结果时，会根据新节点的 key 去对比旧节点数组中的 key，从而找到相应旧节点（这里对应的是一个 key =&gt; index 的 map 映射）。如果没找到就认为是一个新增节点。而如果没有 key，那么就会采用遍历查找的方式去找到对应的旧节点。一种一个 map 映射，另一种是遍历查找。相比而言。map 映射的速度更快。</p> <p>vue 部分源码如下：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// vue项目  src/core/vdom/patch.js  -488行</span>
<span class="token comment">// 以下是为了阅读性进行格式化后的代码</span>

<span class="token comment">// oldCh 是一个旧虚拟节点数组</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isUndef</span><span class="token punctuation">(</span>oldKeyToIdx<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  oldKeyToIdx <span class="token operator">=</span> <span class="token function">createKeyToOldIdx</span><span class="token punctuation">(</span>oldCh<span class="token punctuation">,</span> oldStartIdx<span class="token punctuation">,</span> oldEndIdx<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isDef</span><span class="token punctuation">(</span>newStartVnode<span class="token punctuation">.</span>key<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// map 方式获取</span>
  idxInOld <span class="token operator">=</span> oldKeyToIdx<span class="token punctuation">[</span>newStartVnode<span class="token punctuation">.</span>key<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
  <span class="token comment">// 遍历方式获取</span>
  idxInOld <span class="token operator">=</span> <span class="token function">findIdxInOld</span><span class="token punctuation">(</span>newStartVnode<span class="token punctuation">,</span> oldCh<span class="token punctuation">,</span> oldStartIdx<span class="token punctuation">,</span> oldEndIdx<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>创建 map 函数</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">createKeyToOldIdx</span><span class="token punctuation">(</span><span class="token parameter">children<span class="token punctuation">,</span> beginIdx<span class="token punctuation">,</span> endIdx</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> i<span class="token punctuation">,</span> key<span class="token punctuation">;</span>
  <span class="token keyword">const</span> map <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> beginIdx<span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> endIdx<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    key <span class="token operator">=</span> children<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>key<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isDef</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">)</span> map<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> map<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>遍历寻找</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// sameVnode 是对比新旧节点是否相同的函数</span>
<span class="token keyword">function</span> <span class="token function">findIdxInOld</span><span class="token punctuation">(</span><span class="token parameter">node<span class="token punctuation">,</span> oldCh<span class="token punctuation">,</span> start<span class="token punctuation">,</span> end</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> start<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> end<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> c <span class="token operator">=</span> oldCh<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isDef</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">sameVnode</span><span class="token punctuation">(</span>node<span class="token punctuation">,</span> c<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> i<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="第二题-1-2-3-map-parseint-what-why"><a href="#第二题-1-2-3-map-parseint-what-why" class="header-anchor">#</a> 第二题：['1', '2', '3'].map(parseInt) what &amp; why ?</h2> <p>第一眼看到这个题目的时候，脑海跳出的答案是 [1, 2, 3]，但是<strong>真正的答案是[1, NaN, NaN]</strong>。</p> <ul><li>首先让我们回顾一下，map 函数的第一个参数 callback：</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> new_array <span class="token operator">=</span> arr<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token function">callback</span><span class="token punctuation">(</span><span class="token parameter">currentValue<span class="token punctuation">[</span><span class="token punctuation">,</span> index<span class="token punctuation">[</span><span class="token punctuation">,</span> array<span class="token punctuation">]</span><span class="token punctuation">]</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
<span class="token comment">// Return  element for new_array</span>
<span class="token punctuation">}</span><span class="token punctuation">[</span><span class="token punctuation">,</span> thisArg<span class="token punctuation">]</span><span class="token punctuation">)</span>这个callback一共可以接收三个参数，其中第一个参数代表当前被处理的元素，而第二个参数代表该元素的索引。
</code></pre></div><ul><li>而 parseInt 则是用来解析字符串的，使字符串成为指定基数的整数。
<code>parseInt(string, radix)</code>
接收两个参数，第一个表示被处理的值（字符串），第二个表示为解析时的基数。</li> <li>了解这两个函数后，我们可以模拟一下运行情况</li></ul> <ol><li>parseInt('1', 0) //radix 为 0 时，且 string 参数不以“0x”和“0”开头时，按照 10 为基数处理。这个时候返回 1</li> <li>parseInt('2', 1) //基数为 1（1 进制）表示的数中，最大值小于 2，所以无法解析，返回 NaN</li> <li>parseInt('3', 2) //基数为 2（2 进制）表示的数中，最大值小于 3，所以无法解析，返回 NaN</li></ol> <ul><li>map 函数返回的是一个数组，所以最后结果为[1, NaN, NaN]</li> <li>最后附上 MDN 上对于这两个函数的链接，具体参数大家可以到里面看</li></ul> <ol><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/parseInt" target="_blank" rel="noopener noreferrer">parseInt<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/map" target="_blank" rel="noopener noreferrer">map<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ol> <h2 id="第三题-什么是防抖和节流-有什么区别-如何实现"><a href="#第三题-什么是防抖和节流-有什么区别-如何实现" class="header-anchor">#</a> 第三题：什么是防抖和节流？有什么区别？如何实现？</h2> <p>函数防抖（debounce）：当持续触发事件时，一定时间段内没有再触发事件，事件处理函数才会执行一次，如果设定的时间到来之前，又一次触发了事件，就重新开始延时。如下图，持续触发scroll事件时，并不执行handle函数，当1000毫秒内没有触发scroll事件时，才会延时触发scroll事件。</p> <p>函数节流（throttle）：当持续触发事件时，保证一定时间段内只调用一次事件处理函数。节流通俗解释就比如我们水龙头放水，阀门一打开，水哗哗的往下流，秉着勤俭节约的优良传统美德，我们要把水龙头关小点，最好是如我们心意按照一定规律在某个时间间隔内一滴一滴的往下滴。</p> <p>区别：在于执行的频率不同，一个是 持续触发事件时，只执行最后一次，限定执行次数；一个是持续触发事件时，每隔一定的时间执行一次， 限定执行频率</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">/**
 * 触发高频事件后n秒内函数只会执行一次，如果n秒内高频事件再次被触发，则重新计算时间
 * 函数防抖 (只执行最后一次点击) 
 * 每次触发事件时都取消之前的延时调用
 * @param fn
 * @param delay
 * @returns {Function}
 * @constructor
 */</span>
 <span class="token keyword">const</span> <span class="token function-variable function">Debounce</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">fn<span class="token punctuation">,</span> t</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> delay <span class="token operator">=</span> t <span class="token operator">||</span> <span class="token number">500</span><span class="token punctuation">;</span>
  <span class="token keyword">let</span> timer<span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">let</span> args <span class="token operator">=</span> arguments<span class="token punctuation">;</span>
      <span class="token keyword">if</span><span class="token punctuation">(</span>timer<span class="token punctuation">)</span><span class="token punctuation">{</span>
          <span class="token function">clearTimeout</span><span class="token punctuation">(</span>timer<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
      timer <span class="token operator">=</span> <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
          timer <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
          <span class="token function">fn</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span><span class="token punctuation">,</span> delay<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>


<span class="token comment">/**
 * 高频事件触发，但在n秒内只会执行一次，所以节流会稀释函数的执行频率
 * 函数节流
 * 每次触发事件时都判断当前是否有等待执行的延时函数
 * @param fn
 * @param interval
 * @returns {Function}
 * @constructor
 */</span>
 <span class="token keyword">const</span> <span class="token function-variable function">Throttle</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">fn<span class="token punctuation">,</span> t</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> last<span class="token punctuation">;</span>
    <span class="token keyword">let</span> timer<span class="token punctuation">;</span>
    <span class="token keyword">let</span> interval <span class="token operator">=</span> t <span class="token operator">||</span> <span class="token number">500</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">let</span> args <span class="token operator">=</span> arguments<span class="token punctuation">;</span>
        <span class="token keyword">let</span> now <span class="token operator">=</span> <span class="token operator">+</span><span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>last <span class="token operator">&amp;&amp;</span> now <span class="token operator">-</span> last <span class="token operator">&lt;</span> interval<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token function">clearTimeout</span><span class="token punctuation">(</span>timer<span class="token punctuation">)</span><span class="token punctuation">;</span>
            timer <span class="token operator">=</span> <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
                last <span class="token operator">=</span> now<span class="token punctuation">;</span>
                <span class="token function">fn</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span><span class="token punctuation">,</span> interval<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
            last <span class="token operator">=</span> now<span class="token punctuation">;</span>
            <span class="token function">fn</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

</code></pre></div><h2 id="第四题、javascript内存机制之问-数据是如何存储的"><a href="#第四题、javascript内存机制之问-数据是如何存储的" class="header-anchor">#</a> 第四题、JavaScript内存机制之问——数据是如何存储的？</h2> <blockquote><p>基本数据类型用<code>&lt;font color=&quot;&quot;&gt;栈&lt;/font&gt;</code>存储，引用数据类型用<code>堆</code>存储。  闭包变量是存在堆内存中的。</p> <p>栈：先进后出，</p></blockquote> <p>具体的说，以下数据类型存储在栈中：</p> <ul><li>boolean</li> <li>null</li> <li>undefined</li> <li>number</li> <li>string</li> <li>symbol</li> <li>bigint</li></ul> <p>而所有的对象数据类型（引用数据类型）存放在 堆中。</p> <p>需注意的是：在进行 ** <font color="red">赋值</font> **操作时，原始类型的数据直接完整地复制变量值，对象数据类型的数据则是复制引用地址。</p> <p>因此会有下面的情况:</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token literal-property property">a</span><span class="token operator">:</span><span class="token number">1</span><span class="token punctuation">}</span>
<span class="token keyword">let</span> newObj <span class="token operator">=</span> obj
newObj<span class="token punctuation">.</span>a <span class="token operator">=</span> <span class="token number">2</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>obj<span class="token punctuation">.</span>a<span class="token punctuation">)</span>		<span class="token comment">// 变成了 2</span>
</code></pre></div><p>之所以会这样，是因为 obj 和 newObj 是同一份堆空间的引用地址，改变 newObj,就等于改变了引用地址所指向的对空间内存，这时候通过 obj 来获取这块内存的 值当然会改变。</p> <blockquote><p><strong>为什么不全部用栈来保存呢？</strong></p></blockquote> <ul><li>首先 对于系统栈 来说，它的功能除了保存变量之外，还有创建并切换函数执行上下文的功能，举个例子：</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token parameter">a</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
	console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token parameter">a</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
	<span class="token function">f</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token function">func</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
</code></pre></div><p>假设用 ESP 指针（ 堆栈指针 ） 来保存当前的执行状态，在系统栈中会产生如下的过程：</p> <p>1、调用 func,将 func 函数的上下文压栈，ESP指向栈顶</p> <p>2、执行 func ，又调用 f 函数，将 f 函数的上下文压栈，ESP 指针上移</p> <p>3、执行完 f 函数，将ESP 下移，f 函数对应的栈顶空间被回收</p> <p>4、执行完 func,ESP 下移，func对应的空间被回收</p> <p>图示如下：</p> <p><img src="/assets/img/01-01.67f5b39b.png" alt="img"></p> <p>因此你也看到了，如果采用栈来存储相对基本类型更加复杂的对象数据，那么切换上下文的开销将变得巨大！</p> <p>不过堆内存虽然空间大，能存放大量的数据，但与此同时垃圾内存的回收会带来更大的开销。</p> <h2 id="第五题、v8-引擎如何进行垃圾内存的回收"><a href="#第五题、v8-引擎如何进行垃圾内存的回收" class="header-anchor">#</a> 第五题、V8 引擎如何进行垃圾内存的回收</h2> <p>JS 语言不像 C/C++, 让程序员自己去开辟或者释放内存，而是类似Java，采用自己的一套垃圾回收算法进行自动的内存管理。作为一名资深的前端工程师，对于JS内存回收的机制是需要非常清楚, 以便于在极端的环境下能够分析出系统性能的瓶颈，另一方面，学习这其中的机制，也对我们深入理解JS的闭包特性、以及对内存的高效使用，都有很大的帮助。</p> <h3 id="v8-内存限制"><a href="#v8-内存限制" class="header-anchor">#</a> V8 内存限制</h3> <p>在其他的后端语言中，如Java/Go, 对于内存的使用没有什么限制，但是JS不一样，V8只能使用系统的一部分内存，具体来说</p> <ul><li>64位系统下，V8最多只能分配1.4G</li> <li>32位系统下，V8最多分配0.7G.</li></ul> <p>在前端这样的大内存需求其实并不大，但对于后端而言，nodejs如果遇到一个2G多的文件，那么将无法全部将其读入内存进行各种操作了。</p> <p>我们知道对于栈内存而言，当ESP指针下移，也就是上下文切换之后，栈顶的空间会自动被回收。但对于堆内存而言就比较复杂了，我们下面着重分析堆内存的垃圾回收。</p> <p>在v8里面，所有的Js对象都是直接通过堆来进行分配的。 node也提供了直接的查看方式</p> <div class="language-js extra-class"><pre class="language-js"><code>process<span class="token punctuation">.</span><span class="token function">memoryUsage</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre></div><div class="language-shell extra-class"><pre class="language-shell"><code><span class="token operator">&gt;</span> process.<span class="token function-name function">memoryUsage</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span> rss: <span class="token number">23052288</span>,
  heapTotal: <span class="token number">10731520</span>,
  heapUsed: <span class="token number">6319392</span>,
  external: <span class="token number">8719</span> <span class="token punctuation">}</span>
<span class="token operator">&gt;</span>
</code></pre></div><p>所有的对象类型的数据在JS中都是通过堆进行空间分配的。当我们构造一个对象进行赋值操作的时候，其实相应的内存已经分配到了堆上。你可以不断的这样创建对象，让 V8 为它分配空间，直到堆的大小达到上限。</p> <blockquote><p>V8 为什么要设置内存上限</p></blockquote> <p>究其根本 是由两个因素所共同决定的:</p> <ul><li>一个是JS单线程的执行机制，</li> <li>另一个是JS垃圾回收机制的限制。</li></ul> <p>首先JS是单线程运行的，这意味着一旦进入到垃圾回收，那么其它的各种运行逻辑都要暂停; 另一方面垃圾回收其实是非常耗时间的操作，V8 官方是这样形容的:</p> <blockquote><p>以 1.5GB 的垃圾回收堆内存为例，V8 做一次小的垃圾回收需要50ms 以上，做一次非增量式(ps:后面会解释)的垃圾回收甚至要 1s 以上。</p></blockquote> <p>可见其耗时之久，而且在这么长的时间内，我们的JS代码执行会一直没有响应，造成应用卡顿，导致应用性能和响应能力直线下降。因此，V8 做了一个简单粗暴的选择，那就是限制堆内存，也算是一种权衡的手段，因为大部分情况是不会遇到操作几个G内存这样的场景的。</p> <p>不过，如果你想调整这个内存的限制也不是不行。配置命令如下:</p> <div class="language-shell extra-class"><pre class="language-shell"><code>// 这是调整老生代这部分的内存，单位是MB。后面会详细介绍新生代和老生代内存
<span class="token function">node</span> --max-old-space-size<span class="token operator">=</span><span class="token number">2048</span> xxx.js 
</code></pre></div><p>或者</p> <div class="language-shell extra-class"><pre class="language-shell"><code>// 这是调整新生代这部分的内存，单位是 KB。
<span class="token function">node</span> --max-new-space-size<span class="token operator">=</span><span class="token number">2048</span> xxx.js
</code></pre></div><h3 id="新生代内存的回收"><a href="#新生代内存的回收" class="header-anchor">#</a> 新生代内存的回收</h3> <p>V8 把堆内存分成了两部分进行处理——新生代内存和老生代内存。顾名思义，新生代就是临时分配的内存，存活时间短， 老生代是常驻内存，存活的时间长。V8 的堆内存，也就是两个内存之和。</p> <p><img src="data:image/png;base64,UklGRtIFAABXRUJQVlA4IMYFAACwLgCdASrQAmoAPpFEnUqlo6MhoVVbwLASCWNu4XPw/oM2zYdc/GDF7tctdvQj6vdur5kPOb9BnRMepN6AHS/ZD0nzjN6HLwBlJ2P+I3SgzRvH8qoF5cKZxigXLxUJQ9Qx/ItW4oVeioSh6hj+RatxQq9Evp+weHyC9/h9o+D74Od4OxztHwffWuQUulaPg++tcgpdK0fB99a5BS6Vo+D761xjp6iLK8ozKW359743b7IxWcUgiUUmMKw18nfUsiacB6fNQs2qsNfJ31LImn5PQE7YZcnvKjEJExUAr6TTDZpUKnaiSrFF9G0CxljQJeh4qlIPTIUn9ckgPid96B/DQhpk5OYxrPG8FX0cnJln7lRWesZYHQCTzQsdFkaxoEvQ8q9DzHlPfycByxwHLHAWbget9VkwppfkZcU0uqaSs++tcgpdK0fB99a5BS6Vo+D761yCl0rR8H31rkFLpWhyjNo1HY0CaQC7YHLHAcscByxwHLHAcscByxwHMdEAAP7/apEc9TQlLqxjn9YfftgAAAEXom5L2D/ae0xNIp60+wOvXiA+uVjO/mUdWZAsaraw//Buh/EK/6krJP8yjq2Dmh7/fg+MmfmfVk3/qXbYAPz4O42jtsdtur6+qV3kC6JpuBJ6OaqKtWWbUx5Tn2Q7SkWrik3V+M/2fr9OH7T8WlcMnhc//Dz+t9+9pocSEVeCcb9C/6JB0IcAAHJ0bPkdjQwnZX53s0KIQ77F5FuLbX3i3uep+vv3S0qhOd/x07bHgztQdXvkl1u2ViLOf+niRzS/w9dBKkznrFAZGeAAc2Nnf29ri+rGP8qW+Pufx72cm8tGwkG7DKZDJ/xqUbtGTCr2VB3/hy8DYzpJOpLlN+HdzbRviOrBEoGdBwxDtaGHToTJ8DKj67wYKn5SHie6hK6LARI1Wel3Kp4iJFLkKze4SGfFxwSfiWQaQP9XDZUEXg9CQHnbf/N0kfFji5wC8CvaBn1+4UjV/mcYjPmHY8t4Dywfjtw/0+cur28GtuDG26Kziail4HrbMRufPhD4wAD9ycmAiP42231ASP/lN6V1WYeFxPnFHnKrlUrDHxbObUiEaDFlFi4sXFi4sXFi4sXFkjMDQCSgGAfC0s0Bab95h+dMkg0GoRvikwPhhvAgulwIIZbqjh0GTJpOfREC6FF2mbYe0D54HsiC1qB5Jzwexzzf/Am5RhJXv4PlgSuNHq6yGjy0XMznF38H3LPfh1gQh3UsfCPiwRa/h7bre53ieJxxcW2JGD2zgVauiuNpeO0kbTEGuJZGuTewtJC3BiDlHgQEowFPb4inXah2oxoqlbJa6Cxy0tcMwfhPwipah4PvTxvvyXa3u46lJ/+nuyhYBBtupUlC4e2OzJcuveCTsmGQ5EM+9MOGhSDYh38BOmWeRDCw5A9Qsok997v/2ZGxz1fuMGYFp6lolfUw8Gkxnk0agBAnqgMZzhxU0D0pjzU/NnxyAzWPtCup50Cy/LC4lhezoSldeFkjQ86/q9YUgT+fJ5YPVCbGpoWMeC7AE8x6lBe4BVECkv1b2pKDoXJjEabf9yY5Aon/K/hLsYjTBhSskDfSTmfnyafYsnHxpsKXzoON1+JJuSk+riSs9DAfK4vg6+dektWxicFXrduN2hybMhHSu4pTsRgHS7pDT13gUyR+Fyx7onKL5kkdW30L3VsjKSfnh+5gJnBVnJ20qfQMSqdDn0/DYiy268UmSnquBYwH3nQbGGPQmUXQcF2OFG8t3J2a594MF9p0jK19UMEi+06Rla+q5+NgAyNuZEAAAAaOZLhZryIR7DbJ2mD5oICPygxZ/Yj7U/3PAK1df/DX4rtXBvfnfDeWXEd2L6A8OH8tD0G1IJL3NjQdd+nVUYl+zH8/RkH0D8cIw/rr8lQifeYwz+T8Qy0ZITHy9sn/QAAAtXM3J9WCj8iGQ9oOD+Xpx6vf1PNKT6AQAAAAAAAAAA==" alt="img"></p> <p>根据这两种不同种类的堆内存，V8 采用了不同的回收策略，来根据不同的场景做针对性的优化。</p> <p>首先是新生代的内存，刚刚已经介绍了调整新生代内存的方法，那它的内存默认限制是多少？在 64 位和 32 位系统下分别为 32MB 和 16MB。够小吧，不过也很好理解，新生代中的变量存活时间短，来了马上就走，不容易产生太大的内存负担，因此可以将它设的足够小。</p> <p>那好了，新生代的垃圾回收是怎么做的呢？</p> <p>首先将新生代内存空间一分为二:</p> <p><img src="data:image/png;base64,UklGRuAGAABXRUJQVlA4INQGAADwKgCdASpZAZoAPpFIn0ulpCMhotNp6LASCWVu4XEB/e/6hdYlx7lrNvj5jfON9If+z32n0AOmWyKRnH+S6QwGudYhT5FzgZLf/bd/H/AegukgzJf8h6Df/L5a/qn2D/1v6yHo9jg+BcJxRoXlKiv+9tE/6H84umZqGzxwOwDvBOKNFcGRazZX1HxEqjtZzDAf/2ALbamJgDKGVXpJo/8V6JcI+BcJxRoa0nlXIY2aH144f9S+Xea4rr33tvhYFP2MokglhhbKyEvPLyDR2nS4zEtSONjaLcOd/nJYL1y8oM3GMrmGObFsXCOmqa8R1jQCov1OiFfF3kQnFGit0GO49yrlkig9Mud9aWZpzBpaz5aZsi5jyIsDkaK4MhzfC7Dco78lZ4MwsMjPp5jO5FrNwhXl4sS77qqfb6w2xbFwjR7xfsvUmyDfek2QsrtdXv8aRazcI+4CKSc9rn4nCcPgAP7+xFgT7621tGjH6O3A6nUEF0F08nj64dGBGfNwzzMe5hWmJgEcSaNdALXW3qx9UXTfIfXpNUf+t7ZKkxK/c3HPUpvA/FPfd5EhbSD02LgNMcqPMNxIXlidvBAIWxlQC0P1Nu6yLOJPTAffTtKPGluyFWNyVGzPC3Sm0Iu5m4mFQBxksxCb6nPDh1lUiVuhxVOU/8xl4Qu4IkuyPCO+FxN6xe2U4wUvxQdMtfnv1n7aQn5QmxApy2eiWPO+pr2dfKZHuWpF5Y5T+v/cUMWk85JYwgwWXoI6sMrCHlS0EDJsiR8EWxNfMXCk2u4v8vvWQnPIEhmN9RI2eVgZat7jzO0Ama8xvv/woNLaotyG4s9NMlVrfna15mYoWsEYG2mfGKvhiuVibNsVIpXEpAXZkchhz/82oWNkUdqG+zIhVmeGsIAIyFNnbf0LTnCWQwxjt0cf2cn54R2T5JANiymKTNz+bDpOPbGE/r49j90CPnGahqXhfYEw0ngBbV76jHzUVEe2+kxJtUNZnRSakVYuBpdESWBuYE6WHTg2mMOdaoIT5bFOHV5t+PSSZag5ixZwah1gtwXOv7aBdncZR74Ly45Sj99+04JF6lbGYJbs83XxCiifEC/Kd55g8h68LYnw81Auv/pBqlTga4Ohfp1hkH1pPDJXEjEPx0usBnwd9dHza1H3KkZVe8OKJu244chMTYWDdZs7nLBkx8c5yqPZLbwDWLkG+fnUw1vxCtdaEO9fQ8ZPd8EHNViQrXHAKzKzqArMgAxj1Abo6L9H4wlzT7bYsB4HGbjlE2SCCUPor2m9bZthNYU81YwY/HnuvnvKc40nlWh796dFBflc/HObgJkftNxkMqMP7UC2dmKxuv/xFFG5t7Z5UAhb+xWw1L5HV+VV+8b8ory4ue0E4+6WJS/eXGlJg1Zvbi/UJoGTasRhJtj4t27TuCP496avd9Z54A/+yS66BvtVFN+/nX7fpgnF154Ssoml9G+GdhxfwFTH/MLgmznBP2UrvOP5u147QDhQXdSqywNSRtk2/65iefQYnV/70QQeU9zLZj/F5G9Ob/JEJGC7FSVi8iT4iicFRsZPvGfQwjArSdvGxy9ECwWGzw+1IP3wRV1bnouSCP/NvMc/Uq7VBHHvkASumSbw/QcgNqgwHuPvDK19inyJYFMxAWVsBVab3SkK01PH/RebXFJ2+d4po0c+qE/Ev6LdjRUyjPgZo2OFQMQNEf0RO/C8MD47OZ9vfRJTJ5D7hymKpV1EPQni/K2LpuFJG3ApAx0ca8ioDQt88H+1fpOBueKZhMEUZg8DLKtZ2cqXRe7Ek+T69tZGaOIt/DF4cqPZ3gV5q/NH0eZDafZtOqWk9xxPoTOBvfr62sxySIW1x8g6oPJdcq5Sx74grH8zZE+V9A/dpciJRVSOIZT7S+zsYxpd4gPVXh7CmiwG5TQM8x0t9Otnk9wyrAEhoK0aG5r6EHqk33rRlSyCU1kcvPMPCE8j2QYK2lVSF82qjiX9wt5Xz/hSsUh3MUKpxWG8IHfHI2x1oLD+TRro70VXI0DH/zsQiACnDIb6KdycYwcGPVQoGqtXVux5P+xCTgkoxNupkJ/DeS099mclUOLpY3tR3SNJHVP+Rauc7PZZwbwuoflOEPDFk6RAztFWV4jGOO7a4TEXDLLblyreJyRezAAvTjXjnKPfq9Q+jlnAr1erlr1fRfje2b0mFZwRAzYnRsTCwNr6OXVnDQRRfexJw5FYF8qmxc4geHNz+WGXHIDXIbh+5ez4iXw7/F+wz6BFgfwBmMzQogmX3iXy0q3KOSW3/vzRd7humm3qzcj4YwesvRThItRF9koRH2OUkjIh/OAAAAAAAA==" alt="img"></p> <p>其中From部分表示正在使用的内存，To 是目前闲置的内存。</p> <p>当进行垃圾回收时，V8 将From部分的对象检查一遍，如果是存活对象那么复制到To内存中(在To内存中按照顺序从头放置的)，如果是非存活对象直接回收即可。</p> <p>当所有的From中的存活对象按照顺序进入到To内存之后，From 和 To 两者的角色<code>对调</code>，From现在被闲置，To为正在使用，如此循环。</p> <p>那你很可能会问了，直接将非存活对象回收了不就万事大吉了嘛，为什么还要后面的一系列操作？</p> <p>注意，我刚刚特别说明了，在To内存中按照顺序从头放置的，这是为了应对这样的场景:</p> <p><img src="data:image/png;base64,UklGRmAFAABXRUJQVlA4IFQFAACQKwCdASpBAaEAPpFIn0olpSMhpZjJ4LASCWVu/HyZFrzoH9m1gX3fKOdHPW3RfMvjh9TnlY9BjzSeaNp2W9Q5Cv5L/tP8A7Au2rrr/6X2M7Jz/IcBwQx4q+gHcX8Zn4l0DGidQn/sw/wbjqYAIkTcdTABEXrR8RIPZyzICv8YQTx/4dCbRjYpsnf8x6lJbjqYACUpv3LDI/o/yznm4r8ZTyJvm47RdH8bDVLGEYdTABEbq2d7hd0/zO16KNpXwcJ3X4DYhL+g3HSQceT9o65hcIrhemKzPLPuVq7AV4hlhAgwGZgIkTQlUDH2XC9ALFfn2T0TZEjUnv9xNO2xqYAEyIlm2uIHgsYGY5ykdNmXfTuM0FetsamABMh8OpGa6j8ayRXZ0Fb+2nr+DnZ+H00ebzrY1L1RbZBa71NnP8ALPRXiV60srHgzARImh694q0Ay4K/xhBXd8AESJuOpgAiRNx1L/MAA/v8C6HCdXcN4iT/fg0r96H7RDcv5gD7GFss3nYEf4qwwDdvvCOh/WACcah3RJau0avwL/IefHQ+tRdd8Ar/jANsFQXLEfQ+xoV7ZGTH81jKW/PXXrjeof1NXyxH/9sBNjPXl7+/8GQx9b7ODaKkZol9kE24+OfjPNt/F9DfAyh+OjqEJdpp/0CSBcrpeb6n/baoUW8m117yxg7kcwYdLhc3VF7sj24b195qnZoNscMuu2rIUF7xPU+mFRdvPf3MriZRAKtYRykjZ9wrShhxYjPAzHUhwcxU2ExuL2Grd3oGaEIhluP+elCM7VshvDtMwKkQW0O4zr0Kv/jX1yqRQtT+P9B2tnZcGSEWAa3W71XWKetxhh2+yElqk+YskXn2X9kvN+GoRjNUSBUpd//vvna3U8pXykwxniK9x74suaf7QJEa6gZCoQsWJeo5eD3et1R2cCBo7UjNyvaXvb0wYvhyEAnjl92VNHDR5kN6VBi9rXGYvKP5v6fs/nwY+7a9TSzrk1xAlilQOmd5wwvnmohf+AAFMV7MpqQa7aZgOf/o3KpO1Zfe0LTr9AMBzdV+av4AkvDYnMv29nBrngRtv/U0O69cR/0X8gtg+i78dThD3UMNhd7VrtCdgo6G0GMGr8OKMrxrV2VJrR0ZbXd0rcB/JkTFwDEHULarBZixq2g+INjLhSxdpml3hvH/gfzvDt/FBftgCckk4td0TcdS/nj3ylqYS4UIWYjP8Qj5vUSVTx/73qX0bgOoH11OnyfzuaRW+E/fgZqS8P+JUFSM0S+yCbcfGVHRKfke6IYH7yQcYAjJOIL39v8YqRSoLvVwLlhpIGLynJGpuk+jwHtajo9eQaWgwc/PMa6dI87Zo/UBME8PuPhKgBb9++o5WRe3arYHENgUDIVCFixL1HIzn4NjZeDjJA4AoX7aPRjNts8DqmIlr4iU1fCQGZaEGnOxM48kR20MY7qkfypJvXjMDbmvE1a9BjLQ6hWTC4xHX3cJ5jhf/eQ7qZhbYoQ7xTvCS2d4GGVVC/p+2X+1UYnHeyVKQHAoWV77yuRVDDUceT0RJNx2ItJD2OlWjdBuKXCeY4X/3kO6mYVmNf5zPjIfsMPxUkOj0SMbD+wkLLn9y4EeY9kpvYErD2EC8P5DX9zr0uZzkbzGJ0g7iKSHxK1aUKzYz8VHy6r5O7PV4AmABkotZ2UoEKgVZU0UME+BlQuzSnPCpAGP5KDgcRXG8yd7K8HtqfPjcMzEMXbR9e+o/9+CNwrX1uNR3DyLc/gaWzzXvXkjFDfMClFEDmwSUg+PAigqmkXtkyxk48D7coJEWRsnm/Shx+wPyIMgAAAAAAA==" alt="img"></p> <p>深色的小方块代表存活对象，白色部分表示待分配的内存，由于堆内存是连续分配的，这样零零散散的空间可能会导致稍微大一点的对象没有办法进行空间分配，这种零散的空间也叫做<strong>内存碎片</strong>。刚刚介绍的新生代垃圾回收算法也叫<strong>Scavenge算法</strong>。</p> <p>Scavenge 算法主要就是解决内存碎片的问题，在进行一顿复制之后，To空间变成了这个样子:</p> <p><img src="data:image/png;base64,UklGRiIDAABXRUJQVlA4IBYDAADQHgCdASoYAZEAPpFEnUolpCMhqpX4ALASCWdu4XB6IOzqsI+ib/UdP/0V865umfrK08O/jVN/0v2IbIC3Fv47gAMsG0Ypow17DqjlhaqZR14TNniyoiA5XKZs9NVmblvdtvcO26+3SPZm2y0j40LJHxlEdfTws6tzs+GebuUFKKzO7dzwvfFCUPQJ78SlcjeIkfl2NkskSyFHdz3E/fsjWqAPrVAH1qgDcjd9Jl827tGZVVVVVQH1dVTO3d3d3dxji0u5ZKqqqqqj/AP/9VW27u7u0al7u4xXVVVVVM8nVVRSFw/uNdAOxdNxalFlxGFqWw27vnZjGMYxi3EQ3AAA/v6N47095m9Bv4m5spxUF36yAKq9h1+RyLoQ0oG1/LRn8b4g/TspOeEwTNZaAtRRDcPXzTtZNrVl8Vx9EeEwttXIy2yMNJ5y2vM9Zb9/v6vN7d2KLk6BO4uHaXNdrEEfg46FxW3aHerPXQqXcOxZwFYUSstMlM9vtyeQM7PsX8rDE/umDLkuBRcaQ2g4eXdqWT3GVxdWRKjMuLyW0ZWoPJ2sQOjBN44479V3ELk4kFcZhXYPBBy7aQ3T9F62hT1ha8gkX+BGkEguBrF+SGzfi7fcgv41MwL3k6ut6DWlK0XGl2tsIQ+jSW8FXunUxzLgHbkLeIj9Jlaff2zrcAp8LvYr+1R19K33f6hywPrrBo4+pUOGB0RzFFHC8MVydeF26aCkgaDKKyYCGSZkzQQ7SWV3wtxdUG4I+46QFe5EjT2UzMbLxQjZo2WQy1CBdKhXksUfYCKl79qXy3TkuzxvNBird3jOjgnrmjcnwRMg8iLQssrua+Qv4NfiWfd6NqrI95gMfxw0kiXa4uG/k4zll0VUN9Q2n6kp6uHrBW3EJXZYiSe1V/1H0cLQrIXpOSzns/3aNJ0HNethNZs0UH26qZlxafdSPr1Eq/+Zx1pOCwX5l0qiLOLJGiWYYWSKYUQGpOhP80KpeXZS8MHFH+xTaEQAAACB5uFH+DC+trsH4jsQl7EGo5EhdJV0rz6bJewuypYAAAAA" alt=""></p> <p>是不是整齐了许多？这样就大大方便了后续连续空间的分配。</p> <p>不过Scavenge 算法的劣势也非常明显，就是内存只能使用新生代内存的一半，但是它只存放生命周期短的对象，这种对象<code>一般很少</code>，因此<code>时间</code>性能非常优秀。</p> <h3 id="老生代内存堆的回收"><a href="#老生代内存堆的回收" class="header-anchor">#</a> 老生代内存堆的回收</h3> <p>刚刚介绍了新生代的回收方式，那么新生代中的变量如果经过多次回收后依然存在，那么就会被放入到<code>老生代内存</code>中，这种现象就叫<code>晋升</code>。</p> <p>发生晋升其实不只是这一种原因，我们来梳理一下会有那些情况触发晋升:</p> <ul><li>已经经历过一次 Scavenge 回收。</li> <li>To（闲置）空间的内存占用超过25%。</li></ul> <p>现在进入到老生代的垃圾回收机制当中，老生代中累积的变量空间一般都是很大的，当然不能用<code>Scavenge</code>算法啦，浪费一半空间不说，对庞大的内存空间进行复制岂不是劳民伤财？</p> <p>那么对于老生代而言，究竟是采取怎样的策略进行垃圾回收的呢？</p> <p>第一步，进行标记-清除。这个过程在《JavaScript高级程序设计(第三版)》中有过详细的介绍，主要分成两个阶段，即标记阶段和清除阶段。首先会遍历堆中的所有对象，对它们做上标记，然后对于代码环境中<code>使用的变量</code>以及被<code>强引用</code>的变量取消标记，剩下的就是要删除的变量了，在随后的<code>清除阶段</code>对其进行空间的回收。</p> <p>当然这又会引发内存碎片的问题，存活对象的空间不连续对后续的空间分配造成障碍。老生代又是如何处理这个问题的呢？</p> <p>第二步，整理内存碎片。V8 的解决方式非常简单粗暴，在清除阶段结束后，把存活的对象全部往一端靠拢。</p> <p><img src="data:image/png;base64,UklGRoYFAABXRUJQVlA4IHoFAABwNACdASq2AacAPpFEoUqlo6OhpJy5OLASCWdu4XEUSaxd9/9V4+TgfwZ+LnEYG27B/1X3GfA7/Qewf/LeoB/xehb5iv2A9YL/d/qbwOP+q6xTzuPWk8gDVbPKP9P6ve3br9/2j8gPWn+zfir3ASdql96FPSDVh98A95791/1nm0PrtlmieXbLNE8u2WaJ5dmvQ3JR2v2nfYDdeqAJIjfBJsQDGHA+WT0L1GWXOXUdL9k0UpelBlQg8ipdsss6hwqsBwyBmRGc5ZwNZgpZFmvf83ta4vnUUstEmb7ZeY0+ygFcthbl8Gue1xFFoOMCEiLa8KcjD3QV7dwQobKsQUxnXaiv3Kidttc40OeEWj/pAMLgikKHxePp+lLdOz9csKbHOHZGfpIi3MAWuijuU5DiUlfKKtcyIRiQNZdojeRn6SItzAFrob5skQatYgEvHASpgHMAwRYMy7ZZnuhAXhCqlYlesi9UvqcL4auGroxnaavwDvN9m58b/G2MDSRxVXzWku2WaLOzzWku2WaJ5dss0Ty7ZZonl2yzRPLtlmieXbLNE8u2WaJ5dsssgAD+/qIgDYs/4n+a2EAHhconMtT38BA/U52T6uU7vrAY0FYzO/zHwionvnTVif7Gg4QuIH6/ZkqwlPhZjD49gteLnbs7k9RM4OCJ1KTTE/vn3d14zMci50k1/xLgw0EYXUGtXOHU41q8t1j55Yjm6kKbVwcfjm6QfIykhMONpy1nn8gvUTQT/wDRJFaAB1JwhXpd4rjajS46qXQBtaH6He3wAMdblWvbvuYExpEdvPjA1XRJiy32rekH6cUyvd0b0t4QoJ6XQBtaLQE/2k4X6rn+GXVPMd+1dIxJn/4mFpriJWnNIUNOKNE4SUypZDxDW+dsEufU+uAVv0+xl1n0GFKBAua0kOt0S6uNIJRx/8ZerYmGFWfxv9dMxljFPkHI7TXotRBAAnNHem0stdKM1tyTYfNIBqLtZD6mpG017k6uGZFT7D1bFaaQGVFqDDgosgotnpCetmasLpBndkWIFHAalG2x3CVdJ/9c4foSA00mZV7qJwGHe6j5BU1Tw7CMXpoeTS/nyvPSE9RsOQLlyn8kgK0oARhJ7EJf7lV88C+redwQJbdNFhYYgptOhXnsaP/a1RloisYEMIOosNECOBmJ1KeBDrVEQQza+xWU9S+1IReazgDVVgiLaxeK1opgV/+OepUD9GtxAtiMJdCQwD32l1mLZxnbjXSkdNMJrddk+2Fa1uWOykmtPqT0R9rvzEA+FUa1MN387wOhaW4JnzNcyPiu1LLi/8sX4nYaccJzwmeQQtaZLkGCyaLrf4A+c2LP/8su+n+LThN0fUTaXjlfVjufYtf1PxS9xc5reaBXA1tYPIJ1Jw/wOv53/6uT8RUyLg7kG/g7Sh5tRoffULbq3/slXfn4tCivtdH6Q+2IdhMtHsHoSr+ODcVEKINIEDs+ZLDM7OARmCEjCmZRNn8z0Q6TaFd+eBDQ5ELxgtthn8zV6kft/w//+9DfjWwUuMt6FWbP/n34R2b1RM6lJrRVaAHOgbMcf105X3sEgimzifsufrFDfw+1oGb/Zfgm74bsvEmSvHU+WP5n8+7DRCoWNNscPBITBulIOhFfz6biPK0/JI0tCu4prMn3WYqgKD5V+TKyYUUoWk4FrScBdRem9vWhSoVQWYc2pa6FL6ZCR79AQiZTHmQejM5Wmvp73/EONJISLlLgK7OCnHxxJ1FkWEYOiG1n1lBFI6EF0nwzjHsX7TL/4LHIWzZo1c8ChJDbVm77sX/mQ03zRFQQdsKGrosePmIhAISdglHYseporo2jcmdAR6B+rY6QrzQoY7vxPU7O9fkAAAAAAAAA" alt=""></p> <p>由于是移动对象，它的执行速度不可能很快，事实上也是整个过程中最耗时间的部分。</p> <h3 id="增量标记"><a href="#增量标记" class="header-anchor">#</a> 增量标记</h3> <p>由于JS的单线程机制，V8 在进行垃圾回收的时候，不可避免地会阻塞业务逻辑的执行，倘若老生代的垃圾回收任务很重，那么耗时会非常可怕，严重影响应用的性能。那这个时候为了避免这样问题，V8 采取了增量标记的方案，即将一口气完成的标记任务分为很多小的部分完成，每做完一个小的部分就&quot;歇&quot;一下，就js应用逻辑执行一会儿，然后再执行下面的部分，如果循环，直到标记阶段完成才进入内存碎片的整理上面来。其实这个过程跟React Fiber的思路有点像，这里就不展开了。</p> <p>经过增量标记之后，垃圾回收过程对JS应用的阻塞时间减少到原来了1 / 6, 可以看到，这是一个非常成功的改进。</p> <h2 id="第六题-虚拟dom的优劣如何"><a href="#第六题-虚拟dom的优劣如何" class="header-anchor">#</a> 第六题 虚拟DOM的优劣如何</h2> <h3 id="何为虚拟dom"><a href="#何为虚拟dom" class="header-anchor">#</a> 何为虚拟Dom</h3> <blockquote><p>解释1：用js模拟一颗DOM树，放在浏览器的内存中，当需要变更时，虚拟DOM进行diff算法进行新旧虚拟DOM的对比，将变更放入到队列中。反应到实际的DOM上，减少DOM的操作。</p></blockquote> <blockquote><p>解释2：虚拟DOM将DOM转换为一颗js树。diff算法逐级的进行比较、删除、新增操作。但是如果存在多个相同的元素可能比浪费性能，所以React和Vue引用key值进行区分。</p></blockquote> <p>文档对象模型或 DOM 定义了一个接口，该接口允许 JavaScript 之类的语言访问和操作 HTML 文档。元素由树中的节点表示，并且接口允许我们操纵它们。但是此接口需要付出代价，大量非常频繁的 DOM 操作会使页面速度变慢。</p> <p>Vue 通过在内存中实现文档结构的虚拟表示来解决此问题，其中虚拟节点（VNode）表示 DOM 树中的节点。当需要操纵时，可以在虚拟 DOM的 内存中执行计算和操作，而不是在真实 DOM 上进行操纵。这自然会更快，并且允许虚拟 DOM 算法计算出最优化的方式来更新实际 DOM 结构。</p> <p>一旦计算出，就将其应用于实际的 DOM 树，这就提高了性能，这就是为什么基于虚拟 DOM 的框架（例如 Vue 和 React）如此突出的原因。</p> <h3 id="为什么dom-渲染慢"><a href="#为什么dom-渲染慢" class="header-anchor">#</a> 为什么DOM 渲染慢？</h3> <p><img src="/assets/img/01-08.9316bd91.png" alt="img"></p> <p>所谓DOM渲染，即浏览器将HTML字符串转换成网页视图并渲染视图的过程。</p> <ol><li>首先，浏览器的HTML解析器，会对HTML字符串进行解析，并将它转换成DOM树，同时，CSS解析器也会解析HTML使用到的CSS样式，生成一系列CSS规则。</li> <li>然后浏览器的渲染引擎将DOM树和CSS规则进行整合，并生成一个可用于视图渲染的DOM渲染树。</li> <li>接着确定DOM布局，即每一个节点在浏览器中的确切位置。</li> <li>最后一步是进行绘制，将每一个节点的每一个像素都绘制在屏幕上。</li></ol> <blockquote><p>为了理解这一过程的复杂性，我们可以对HTML解析器的处理做一个特写：在HTML解析器中，有两个程序交替执行：分词程序和解析程序；分词程序负责将HTML字符串划分成合法的DOM标签字符串，然后将它们交给用于处理的解析器，解析器将它们添加到正在构建的DOM树中；当分词器解析所有字符串时，将构建DOM树。</p></blockquote> <p>您可以理解为什么DOM呈现如此缓慢：这个过程真的太复杂了,DOM对象本身也是一个js对象，所以严格来说，并不是操作这个对象慢，而是说操作了这个对象后，会触发一些浏览器行为，比如布局（layout）和绘制（paint）。 在web页面交互中添加和删除DOM将大大降低视图呈现和交互的效率。</p> <h3 id="为什么我们要使用虚拟dom"><a href="#为什么我们要使用虚拟dom" class="header-anchor">#</a> 为什么我们要使用虚拟DOM</h3> <ul><li>保证性能下限</li> <li>不需要手动优化的情况下，我依然可以给你提供过得去的性能</li> <li>跨平台</li></ul> <h4 id="保证性能下限"><a href="#保证性能下限" class="header-anchor">#</a> 保证性能下限</h4> <p>框架的虚拟 DOM 需要适配任何上层 API 可能产生的操作，它的一些 DOM 操作的实现必须是普适的，所以它的性能并不是最优的；但是比起粗暴的 DOM 操作性能要好很多，因此框架的虚拟 DOM 至少可以保证在你不需要手动优化的情况下，依然可以提供还不错的性能，即保证性能的下限；</p> <p>例如比较 innerHTML vs. Virtual DOM 的重绘性能消耗：</p> <ul><li><p>innerHTML:  render html string O(template size) + 重新创建所有 DOM 元素 O(DOM size)</p></li> <li><p>Virtual DOM: render Virtual DOM + diff O(template size) + 必要的 DOM 更新 O(DOM change)</p></li></ul> <p>Virtual DOM render + diff 显然比渲染 html 字符串要慢，但是！它依然是纯 js 层面的计算，比起后面的 DOM 操作来说，依然便宜了太多。</p> <p>可以看到，innerHTML 的总计算量不管是 js 计算还是 DOM 操作都是和整个界面的大小相关，但 Virtual DOM 的计算量里面，只有 js 计算和界面大小相关，DOM 操作是和数据的变动量相关的。</p> <p>前面说了，和 DOM 操作比起来，js 计算是极其便宜的。这才是为什么要有 Virtual DOM：它保证了不管你的数据变化多少，每次重绘的性能都可以接受。保证了性能的下线。</p> <h4 id="不需要手动优化的情况下-我依然可以给你提供过得去的性能"><a href="#不需要手动优化的情况下-我依然可以给你提供过得去的性能" class="header-anchor">#</a> 不需要手动优化的情况下，我依然可以给你提供过得去的性能</h4> <p>这是一个性能 vs. 可维护性的取舍。框架的意义在于为你掩盖底层的 DOM 操作，让你用更声明式的方式来描述你的目的，从而让你的代码更容易维护。没有任何框架可以比纯手动的优化 DOM 操作更快，因为框架的 DOM 操作层需要应对任何上层 API 可能产生的操作，它的实现必须是普适的。针对任何一个 benchmark，我都可以写出比任何框架更快的手动优化，但是那有什么意义呢？在构建一个实际应用的时候，你难道为每一个地方都去做手动优化吗？出于可维护性的考虑，这显然不可能。框架给你的保证是，你在不需要手动优化的情况下，我依然可以给你提供过得去的性能。</p> <h4 id="跨平台"><a href="#跨平台" class="header-anchor">#</a> 跨平台</h4> <p>虚拟 DOM 本质上是 JavaScript 对象,而 DOM 与平台强相关，相比之下虚拟 DOM 可以进行更方便地跨平台操作，例如服务器渲染、weex 开发等等。</p> <h2 id="第七题、什么是渲染函数-举个例子"><a href="#第七题、什么是渲染函数-举个例子" class="header-anchor">#</a> 第七题、什么是渲染函数？举个例子</h2> <p>ue 允许我们以多种方式构建模板，其中最常见的方式是只把 HTML 与特殊指令和 mustache 标签一起用于响应功能。但是你也可以通过 JavaScript 使用特殊的函数类（称为渲染函数）来构建模板。这些函数与编译器非常接近，这意味着它们比其他模板类型更高效、快捷。由于你使用 JavaScript 编写渲染函数，因此可以在需要的地方自由使用该语言直接添加自定义函数。</p> <p>对于标准 HTML 模板的高级方案非常有用。</p> <p><strong>这里是用 HTML 作为模板的 Vue 程序</strong></p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  <span class="token literal-property property">el</span><span class="token operator">:</span> <span class="token string">'#app'</span><span class="token punctuation">,</span>
  <span class="token literal-property property">data</span><span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token literal-property property">fruits</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">'Apples'</span><span class="token punctuation">,</span> <span class="token string">'Oranges'</span><span class="token punctuation">,</span> <span class="token string">'Kiwi'</span><span class="token punctuation">]</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token literal-property property">template</span><span class="token operator">:</span>
      <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">&lt;div&gt;
         &lt;h1&gt;Fruit Basket&lt;/h1&gt;
         &lt;ol&gt;
           &lt;li v-for=&quot;fruit in fruits&quot;&gt;{{ fruit }}&lt;/li&gt;
         &lt;/ol&gt;
      &lt;/div&gt;</span><span class="token template-punctuation string">`</span></span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

</code></pre></div><p><strong>这里是用渲染函数开发的同一个程序：</strong></p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  <span class="token literal-property property">el</span><span class="token operator">:</span> <span class="token string">'#app'</span><span class="token punctuation">,</span>
  <span class="token literal-property property">data</span><span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token literal-property property">fruits</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">'Apples'</span><span class="token punctuation">,</span> <span class="token string">'Oranges'</span><span class="token punctuation">,</span> <span class="token string">'Kiwi'</span><span class="token punctuation">]</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token function-variable function">render</span><span class="token operator">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">createElement</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">'div'</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>
      <span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">'h1'</span><span class="token punctuation">,</span> <span class="token string">'Fruit Basket'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
      <span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">'ol'</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>fruits<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">fruit</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> 
        <span class="token keyword">return</span> <span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">'li'</span><span class="token punctuation">,</span> fruit<span class="token punctuation">)</span><span class="token punctuation">;</span> 
      <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

</code></pre></div><p><strong>输出：</strong></p> <p>Fruit Basket</p> <ol><li>Apples</li> <li>Oranges</li> <li>Kiwi</li></ol> <p>在上面的例子中，我们用了一个函数，它返回一系列 <code>createElement()</code> 调用，每个调用负责生成一个元素。尽管 v-for 指令在基于 HTML 的模板中起作用，但是当使用渲染函数时，可以简单地用标准 <code>.map()</code> 函数遍历 fruits 数据数组。</p> <h2 id="第八题、在大型-vue-程序中管理状态的推荐方法是什么-为什么"><a href="#第八题、在大型-vue-程序中管理状态的推荐方法是什么-为什么" class="header-anchor">#</a> 第八题、在大型 Vue 程序中管理状态的推荐方法是什么？为什么？</h2> <p>当程序在功能和代码方面不断增长时，状态管理会变得困难，并且使用无穷无尽的下游网络 prop 和上游事件当然不是明智的决定。在这种情况下，有必要将状态管理转移到中央管理系统。 Vue 生态系统中提供了 Vuex，它是官方的状态管理库，也是推荐用于集中存储状态的模式。</p> <p>Vuex 允许维护中央状态。组件将 Vuex 用作响应性数据存储，并在状态更新时进行更新。多个或者不相关的组件可以依赖于相同的中央存储。</p> <p>在这种情况下，Vue 充当纯 View 层。要修改状态，视图层（例如按钮或交互式组件）需要发出 Vuex <code>Action</code>，然后执行所需的任务。为了更新或修改状态，Vuex 提供了 <code>Mutations</code>。</p> <p>这个工作流程的目的是留下可用的操作痕迹。</p> <h2 id="第九题、vue-react路由传参的三种基本方式"><a href="#第九题、vue-react路由传参的三种基本方式" class="header-anchor">#</a> 第九题、vue，react路由传参的三种基本方式</h2> <p>现有如下场景，点击父组件的li元素跳转到子组件中，并携带参数，便于子组件获取数据。</p> <h3 id="vue-路由传参的三种方式"><a href="#vue-路由传参的三种方式" class="header-anchor">#</a> vue 路由传参的三种方式</h3> <p>父组件中</p> <div class="language-vue extra-class"><pre class="language-vue"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span>	<span class="token attr-name">v-for</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>article in articles<span class="token punctuation">&quot;</span></span> <span class="token attr-name">@click</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>getDescribe(article.id)<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>...<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">&gt;</span></span>
</code></pre></div><h4 id="方案一"><a href="#方案一" class="header-anchor">#</a> 方案一</h4> <div class="language-vue extra-class"><pre class="language-vue"><code>getDescribe(id){
	this.$router.push({
		path:`/describe/${id}`
	})
}
</code></pre></div><p>不过需要 对应路由配置如下</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token punctuation">{</span>
    <span class="token literal-property property">path</span><span class="token operator">:</span><span class="token string">'/describe/:id'</span><span class="token punctuation">,</span>
    <span class="token literal-property property">name</span><span class="token operator">:</span><span class="token string">'Describe'</span><span class="token punctuation">,</span>
    <span class="token literal-property property">component</span><span class="token operator">:</span>Describe
<span class="token punctuation">}</span>
</code></pre></div><p>很显然，需要在path中添加/:id来对应 $router.push 中path携带的参数。在子组件中可以使用如下方式来获取传递的参数值。</p> <p>子组件获取参数</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code>$route<span class="token punctuation">.</span>params<span class="token punctuation">.</span>id
</code></pre></div><h4 id="方案二"><a href="#方案二" class="header-anchor">#</a> 方案二</h4> <p>父组件中：通过路由属性中的name来确定匹配的路由，通过params来传递参数</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">this</span><span class="token punctuation">.</span>$router<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
    <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">'Describe'</span><span class="token punctuation">,</span>
    <span class="token literal-property property">params</span><span class="token operator">:</span> <span class="token punctuation">{</span>
        <span class="token literal-property property">id</span><span class="token operator">:</span> id
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><p>对应路由配置: 注意这里不能使用:/id来传递参数了，因为父组件中，已经使用params来携带参数了。</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token punctuation">{</span>
     <span class="token literal-property property">path</span><span class="token operator">:</span> <span class="token string">'/describe'</span><span class="token punctuation">,</span>
     <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">'Describe'</span><span class="token punctuation">,</span>
     <span class="token literal-property property">component</span><span class="token operator">:</span> Describe
   <span class="token punctuation">}</span>
</code></pre></div><p>子组件中: 这样来获取参数</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code>$route<span class="token punctuation">.</span>params<span class="token punctuation">.</span>id
</code></pre></div><h4 id="方案三"><a href="#方案三" class="header-anchor">#</a> 方案三</h4> <p>父组件：使用path来匹配路由，然后通过query来传递参数，这种情况下 query传递的参数会显示在url后面?id=？</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">this</span><span class="token punctuation">.</span>$router<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
    <span class="token literal-property property">path</span><span class="token operator">:</span> <span class="token string">'/describe'</span><span class="token punctuation">,</span>
    <span class="token literal-property property">query</span><span class="token operator">:</span> <span class="token punctuation">{</span>
        <span class="token literal-property property">id</span><span class="token operator">:</span> id
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><p>对应路由配置：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token punctuation">{</span>
     <span class="token literal-property property">path</span><span class="token operator">:</span> <span class="token string">'/describe'</span><span class="token punctuation">,</span>
     <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">'Describe'</span><span class="token punctuation">,</span>
     <span class="token literal-property property">component</span><span class="token operator">:</span> Describe
 <span class="token punctuation">}</span>
</code></pre></div><p>对应子组件: 这样来获取参数</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code>$route<span class="token punctuation">.</span>query<span class="token punctuation">.</span>id
</code></pre></div><h3 id="react-router-页面传值的三种方法"><a href="#react-router-页面传值的三种方法" class="header-anchor">#</a> React  Router 页面传值的三种方法</h3> <h4 id="方案一、props-params"><a href="#方案一、props-params" class="header-anchor">#</a> 方案一、props.params</h4> <blockquote><p>props.params</p></blockquote> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">import</span> <span class="token punctuation">{</span>Router<span class="token punctuation">,</span>Route<span class="token punctuation">,</span>hashHistory<span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'react-router'</span>

<span class="token keyword">class</span> <span class="token class-name">APP</span> <span class="token keyword">extends</span> <span class="token class-name">React<span class="token punctuation">.</span>Component</span><span class="token punctuation">{</span>
    <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
		<span class="token keyword">return</span> <span class="token punctuation">(</span>
        <span class="token operator">&lt;</span>Router history<span class="token operator">=</span><span class="token punctuation">{</span>hashHistory<span class="token punctuation">}</span><span class="token operator">&gt;</span>
            <span class="token operator">&lt;</span>Route path<span class="token operator">=</span><span class="token string">'/user/:name'</span> component<span class="token operator">=</span><span class="token punctuation">{</span>UserPage<span class="token punctuation">}</span><span class="token operator">&gt;</span><span class="token operator">&lt;</span><span class="token operator">/</span>Route<span class="token operator">&gt;</span>
        <span class="token operator">&lt;</span><span class="token operator">/</span>Router<span class="token operator">&gt;</span>
        <span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>上面指定参数 <font color="red">name</font></p> <p>使用方法1：link组件传值</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">import</span> <span class="token punctuation">{</span>Link<span class="token punctuation">,</span>hashHiStory<span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'react-router'</span>

<span class="token operator">&lt;</span>Link to<span class="token operator">=</span><span class="token string">&quot;/user/sam&quot;</span><span class="token operator">&gt;</span>

</code></pre></div><p>使用方法2：history 跳转</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">import</span> <span class="token punctuation">{</span>Link<span class="token punctuation">,</span>hashHiStory<span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'react-router'</span>

hasHistory<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token string">&quot;/user/sam&quot;</span><span class="token punctuation">)</span>
</code></pre></div><p>对应获取参数的方法</p> <div class="language-react extra-class"><pre class="language-text"><code>this.props.params.name
</code></pre></div><p>**上面的方法可以传递一个或多个值，但是每个值的类型都是字符串，没法传递一个对象， 如果传递的话可以将json对象转换为字符串，然后传递过去，传递过去之后再将json字符串转换为对象将数据取出来 **</p> <p>如：定义路由：</p> <div class="language-react extra-class"><pre class="language-text"><code>&lt;Route path='/user/:data' component={UserPage}&gt;
</code></pre></div><p>使用：</p> <div class="language-react extra-class"><pre class="language-text"><code>var data={id:3,name:sam,age:36}
data = JSON.stringify(data)
var path = `/user/${data}`
</code></pre></div><div class="language-react extra-class"><pre class="language-text"><code>&lt;Link to={path}&gt;用户&lt;/Link&gt;
</code></pre></div><div class="language-react extra-class"><pre class="language-text"><code>hasHistory.push(path)
</code></pre></div><p>获取数据：</p> <div class="language-react extra-class"><pre class="language-text"><code>var data = JSON.parse(this.props.params.data)
var {id,name,age} = data
</code></pre></div><h4 id="方案2、query"><a href="#方案2、query" class="header-anchor">#</a> 方案2、query</h4> <p>query方式使用很简单，类似于表单中的get方法，传递参数为明文：</p> <p>路由定义</p> <div class="language-react extra-class"><pre class="language-text"><code>&lt;Route path='/user' component={UserPage}&gt;&lt;/Route&gt;
</code></pre></div><p>使用：</p> <div class="language-react extra-class"><pre class="language-text"><code>var data={id:3,name:sam,age:36}
var path = {pathname:'/user',query:data}

// Link
&lt;Link to={path}&gt;用户&lt;/Link&gt;

// hasHistory
hasHistory.push(path)
</code></pre></div><p>获取数据：</p> <div class="language-react extra-class"><pre class="language-text"><code>var data = this.props.location.query
var {id,name,age} = data
</code></pre></div><h4 id="方案三、state"><a href="#方案三、state" class="header-anchor">#</a> 方案三、state</h4> <p>state方式类似于post方式，使用方式和query类似，</p> <p>路由定义：</p> <div class="language-react extra-class"><pre class="language-text"><code>&lt;Route path='/user' component={UserPage}&gt;&lt;/Route&gt;
</code></pre></div><p>使用：</p> <div class="language-react extra-class"><pre class="language-text"><code>var data = {id:3,name:same,age:36}
var path = {pathname:'/user',state:data}

// Link
&lt;Link to={path}&gt;用户&lt;/Link&gt;

// hasHistory
hashHistory.push(path)
</code></pre></div><p>获取：</p> <div class="language-react extra-class"><pre class="language-text"><code>var data = this.props.location.state;
var {id,name,age} = data;
</code></pre></div><p>state方式依然可以传递任意类型的数据，而且可以不以明文方式传输。</p> <p>可以在实现后对比地址栏的URL来观察三种传值方式URL的区别</p> <h2 id="第十题、简单介绍下webpack的工作原理"><a href="#第十题、简单介绍下webpack的工作原理" class="header-anchor">#</a> 第十题、简单介绍下webpack的工作原理</h2> <p>webpack 的运行流程是一个串行的过程，从启动到结束会依次执行一下流程</p> <ul><li>初始化参数：从配置文件和shell 语句中读取与合并参数，得出最终的参数</li> <li>开始编译：用上一步得到的参数初始化 Compiler 对象，加载所有配置的插件，执行 Compiler 对象的 run 方法开始执行编译</li> <li>确定入口：根据配置中的 entry 找出所有的入口文件</li> <li>编译模块：从入口文件开始，调用所有配置的loader 对模块进行 解析编译，再找出该模块依赖的模块，再递归本步骤直到所有入口依赖的文件都经过了本步骤的处理</li> <li>完成模块编译：在经过上述 步骤使用 loader 解析完所有模块之后，得到了每个模块被解析后的最终内容以及它们之间的依赖关系，</li> <li>输出资源：根据入口和模块之间的依赖关系，开始打包组装成一个个包含多个模块的chunk,再把每个chunk转换成一个单独的文件加入到输出列表，这不是可以修改输出内容的最后机会</li> <li>输出完成：在确定好输出内容后，根据配置确定输出的路径和文件名，把文件内容写入到文件系统</li></ul> <h2 id="第十一题、vue-中的-computed-和-watch-的区别在哪里"><a href="#第十一题、vue-中的-computed-和-watch-的区别在哪里" class="header-anchor">#</a> 第十一题、Vue 中的 computed 和 watch 的区别在哪里</h2> <ul><li>computed：计算属性</li></ul> <p>计算属性是由data中的已知值，得到的一个新值。
这个新值只会根据已知值的变化而变化，其他不相关的数据的变化不会影响该新值。
计算属性不在data中，计算属性新值的相关已知值在data中。
别人变化影响我自己。</p> <ul><li>watch：监听数据的变化</li></ul> <p>监听data中数据的变化
监听的数据就是data中的已知值
我的变化影响别人</p> <p>1.watch擅长处理的场景：一个数据影响多个数据</p> <p>2.computed擅长处理的场景：一个数据受多个数据影响</p> <h2 id="第十二题、script标签中defer和async的区别是什么"><a href="#第十二题、script标签中defer和async的区别是什么" class="header-anchor">#</a> 第十二题、script标签中defer和async的区别是什么？</h2> <p>默认情况下，脚本的下载和执行将会按照文档的先后顺序同步进行。当脚本下载和执行的时候，文档解析就会被阻塞，在脚本下载和执行完成之后文档才能往下继续进行解析。</p> <p>下面是async和defer两者区别：</p> <ul><li>当script中有defer属性时，脚本的加载过程和文档加载是异步发生的，等到文档解析完(DOMContentLoaded事件发生)脚本才开始执行。</li> <li>当script有async属性时，脚本的加载过程和文档加载也是异步发生的。但脚本下载完成后会停止HTML解析，执行脚本，脚本解析完继续HTML解析。</li> <li>当script同时有async和defer属性时，执行效果和async一致。</li></ul> <h2 id="第十三题、js数据类型之问-概念篇"><a href="#第十三题、js数据类型之问-概念篇" class="header-anchor">#</a> 第十三题、JS数据类型之问-概念篇</h2> <h3 id="_1、js原始数据类型有哪些-引用数据类型有哪些"><a href="#_1、js原始数据类型有哪些-引用数据类型有哪些" class="header-anchor">#</a> 1、JS原始数据类型有哪些？引用数据类型有哪些？</h3> <p>在 JS 中，存在着 7中原始值，分别是：</p> <ul><li>boolean</li> <li>null</li> <li>undefined</li> <li>number</li> <li>string</li> <li>symbol</li> <li>bigint</li></ul> <p>引用数据类型：对象<font color="red"><code>Object</code></font>(包含 普通对象-Object，数组对象-Array，正则对象-RegExp，日期对象-Date，数学函数-Math，函数对象-Function)</p> <h3 id="_2、说出下面运行的结果-解释原因"><a href="#_2、说出下面运行的结果-解释原因" class="header-anchor">#</a> 2、说出下面运行的结果，解释原因</h3> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token parameter">person</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  person<span class="token punctuation">.</span>age <span class="token operator">=</span> <span class="token number">26</span>
  person <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">'hzj'</span><span class="token punctuation">,</span>
    <span class="token literal-property property">age</span><span class="token operator">:</span> <span class="token number">18</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> person
<span class="token punctuation">}</span>
<span class="token keyword">const</span> p1 <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">'fyq'</span><span class="token punctuation">,</span>
  <span class="token literal-property property">age</span><span class="token operator">:</span> <span class="token number">19</span>
<span class="token punctuation">}</span>
<span class="token keyword">const</span> p2 <span class="token operator">=</span> <span class="token function">test</span><span class="token punctuation">(</span>p1<span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>p1<span class="token punctuation">)</span> <span class="token comment">// -&gt; ?</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>p2<span class="token punctuation">)</span> <span class="token comment">// -&gt; ?</span>

</code></pre></div><p>结果是：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token literal-property property">p1</span><span class="token operator">:</span><span class="token punctuation">{</span><span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">&quot;fyq&quot;</span><span class="token punctuation">,</span> <span class="token literal-property property">age</span><span class="token operator">:</span> <span class="token number">26</span><span class="token punctuation">}</span>
<span class="token literal-property property">p2</span><span class="token operator">:</span><span class="token punctuation">{</span><span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">&quot;hzj&quot;</span><span class="token punctuation">,</span> <span class="token literal-property property">age</span><span class="token operator">:</span> <span class="token number">18</span><span class="token punctuation">}</span>
</code></pre></div><blockquote><p>原因: 在函数传参的时候传递的是对象在堆中的内存地址值，test函数中的实参person是p1对象的内存地址，通过调用person.age = 26确实改变了p1的值，但随后person变成了另一块内存空间的地址，并且在最后将这另外一份内存空间的地址返回，赋给了p2。</p></blockquote> <h3 id="_3、null-是对象吗-为什么"><a href="#_3、null-是对象吗-为什么" class="header-anchor">#</a> 3、null 是对象吗？为什么？</h3> <p>结论：null  不是 对象</p> <p>解释：虽然 typeof null 会输出 object，但是这只是 JS 存在的一个悠久 Bug。在 JS 的最初版本中使用的是 32 位系统，为了性能考虑使用低位存储变量的类型信息，000 开头代表是对象然而 null 表示为全零，所以将它错误的判断为 object 。</p> <blockquote><p>在ECMA6中, 曾经有提案为历史平凡, 将type null的值纠正为null, 但最后提案被拒了. 理由是历史遗留代码太多, 不想得罪人, 不如继续将错就错当和事老  , 参考 [harmony:typeof_null <a href="https://link.zhihu.com/?target=http%3A//wiki.ecmascript.org/doku.php%3Fid%3Dharmony%3atypeof_null" target="_blank" rel="noopener noreferrer">ES Wiki]<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p></blockquote> <h3 id="_4、-1-tostring-为什么可以调用"><a href="#_4、-1-tostring-为什么可以调用" class="header-anchor">#</a> 4、'1'.toString() 为什么可以调用</h3> <p>其实在这个语句运行的过程中做了这样几件事</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">var</span> s <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token string">&quot;1&quot;</span><span class="token punctuation">)</span>
s<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
s <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
</code></pre></div><p>第一步: 创建Object类实例。注意为什么不是String ？ 由于Symbol和BigInt的出现，对它们调用new都会报错，目前ES6规范也不建议用new来创建基本类型的包装类。</p> <p>第二步: 调用实例方法。</p> <p>第三步: 执行完方法立即销毁这个实例。</p> <p>整个过程体现了<code>基本包装类型</code>的性质，而基本包装类型恰恰属于基本数据类型，包括Boolean, Number和String。</p> <blockquote><p>参考:《JavaScript高级程序设计(第三版)》P118</p></blockquote> <h3 id="_5、0-1-0-2-为什么不等于0-3"><a href="#_5、0-1-0-2-为什么不等于0-3" class="header-anchor">#</a> 5、0.1+0.2 为什么不等于0.3？</h3> <p>0.1 和 0.2 在转换成 2进制后会无限循环，由于标准位数的限制后面多余的位数会被截掉，此时就已经出现了精度的丢失，相加后因浮点数小数位的限制而截断的二进制数字在转换为十进制就会变成  0.30000000000000004 。</p> <h3 id="_6、如何理解-bigint"><a href="#_6、如何理解-bigint" class="header-anchor">#</a> 6、如何理解 BigInt ?</h3> <h4 id="什么是-bigint"><a href="#什么是-bigint" class="header-anchor">#</a> 什么是 BigInt ?</h4> <blockquote><p>BigInt 是一种新的数据类型，用于当整数值大于Number 数据类型支持的范围时，这种数据类型允许我们安全的对<font color="red">大整数</font>执行算术操作，表示高分辨率的时间戳，使用大整数id,等等，而不需要使用库。</p></blockquote> <h4 id="为什么需要-bigint"><a href="#为什么需要-bigint" class="header-anchor">#</a> 为什么需要 BigInt ?</h4> <p>在 JS 中，所有的数字都已双精度64位 浮点格式表示，那这会带来什么问题呢？</p> <p>这导致JS中的Number无法精确表示非常大的整数，它会将非常大的整数四舍五入，确切地说，JS中的Number类型只能安全地表示-9007199254740991(-(2^53-1))和 9007199254740991（(2^53-1)），任何超出此范围的整数值都可能失去精度。</p> <div class="language-javas extra-class"><pre class="language-text"><code>console.log(999999999999999999)  // -&gt; 1000000000000000000
</code></pre></div><p>同时也会有一定的安全性问题:</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token number">9007199254740992</span> <span class="token operator">===</span> <span class="token number">9007199254740993</span>	<span class="token comment">// -&gt; true </span>
</code></pre></div><h4 id="如何创建并使用bigint"><a href="#如何创建并使用bigint" class="header-anchor">#</a> 如何创建并使用BigInt？</h4> <p>要创建BigInt，只需要在数字末尾追加n即可。</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> <span class="token number">9007199254740995n</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// → 9007199254740995n</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> <span class="token number">9007199254740995</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">// → 9007199254740996</span>
</code></pre></div><p>另一种创建BigInt的方法是用BigInt()构造函数、</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token function">BigInt</span><span class="token punctuation">(</span><span class="token string">&quot;9007199254740995&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// → 9007199254740995n</span>
</code></pre></div><p>简单使用如下:</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token number">10n</span> <span class="token operator">+</span> <span class="token number">20n</span><span class="token punctuation">;</span>    <span class="token comment">// → 30n	</span>
<span class="token number">10n</span> <span class="token operator">-</span> <span class="token number">20n</span><span class="token punctuation">;</span>    <span class="token comment">// → -10n	</span>
<span class="token operator">+</span><span class="token number">10n</span><span class="token punctuation">;</span>         <span class="token comment">// → TypeError: Cannot convert a BigInt value to a number	</span>
<span class="token operator">-</span><span class="token number">10n</span><span class="token punctuation">;</span>         <span class="token comment">// → -10n	</span>
<span class="token number">10n</span> <span class="token operator">*</span> <span class="token number">20n</span><span class="token punctuation">;</span>    <span class="token comment">// → 200n	</span>
<span class="token number">20n</span> <span class="token operator">/</span> <span class="token number">10n</span><span class="token punctuation">;</span>    <span class="token comment">// → 2n	</span>
<span class="token number">23n</span> <span class="token operator">%</span> <span class="token number">10n</span><span class="token punctuation">;</span>    <span class="token comment">// → 3n	</span>
<span class="token number">10n</span> <span class="token operator">**</span> <span class="token number">3n</span><span class="token punctuation">;</span>    <span class="token comment">// → 1000n	</span>

<span class="token keyword">const</span> x <span class="token operator">=</span> <span class="token number">10n</span><span class="token punctuation">;</span>	
<span class="token operator">++</span>x<span class="token punctuation">;</span>          <span class="token comment">// → 11n	</span>
<span class="token operator">--</span>x<span class="token punctuation">;</span>          <span class="token comment">// → 9n</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">//&quot;bigint&quot;</span>

</code></pre></div><h4 id="值得警惕的点"><a href="#值得警惕的点" class="header-anchor">#</a> 值得警惕的点</h4> <ol><li><p>BigInt 不支持一元加号运算符，这可能时某些程序可能依赖于 + 始终生成 Number 的不变量，或者抛出异常。另外，更改 + 的行为也会破坏 asm.js 代码。</p></li> <li><p>因为隐式类型转换可能丢失信息，所以不允许在bigint 和 Number 之间进行混合操作。当混合使用大整数和浮点数时，结果值可能无法有 BigInt 或 Number 精确表示。</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token number">10</span> <span class="token operator">+</span> <span class="token number">10n</span>		<span class="token comment">// -&gt; TypeError</span>
</code></pre></div></li> <li><p>不能将 BigInt 传递给Web api 和 内置的 JS 函数，这些函数需要一个 Number类型的数字，尝试这样做会报 TypeError 错误。</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code>Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span><span class="token number">2n</span><span class="token punctuation">,</span><span class="token number">4n</span><span class="token punctuation">,</span><span class="token number">6n</span><span class="token punctuation">)</span>		<span class="token comment">// -&gt; TypeError</span>
</code></pre></div></li> <li><p>当 Boolean 类型与 BigInt 类型相遇时，BigInt 的处理方式与 Number 类似，换句话说，只要不是 0n,BigInt 就被视为 truthy 的值</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token number">0n</span><span class="token punctuation">)</span><span class="token punctuation">{</span>	<span class="token comment">// 条件判断位 false</span>
    
<span class="token punctuation">}</span>

<span class="token keyword">if</span><span class="token punctuation">(</span><span class="token number">3n</span><span class="token punctuation">)</span><span class="token punctuation">{</span>	<span class="token comment">// 条件位 true</span>
    
<span class="token punctuation">}</span>

</code></pre></div></li> <li><p>元素都为 BigInt 的数组可以 进行 sort</p></li> <li><p>BigInt 可以正常的进行位运算，如 |、&amp;、&lt;&lt;、和 ^</p></li></ol> <h2 id="第十四题、能不能说一说浏览器缓存"><a href="#第十四题、能不能说一说浏览器缓存" class="header-anchor">#</a> 第十四题、能不能说一说浏览器缓存</h2> <p>缓存是性能优化中非常重要的一环，浏览器的缓存机制对开发也是非常重要的知识点。接下来以三个部分来把浏览器的缓存机制说清楚：</p> <ul><li>强缓存</li> <li>协商缓存</li> <li>缓存位置</li></ul> <h3 id="强缓存"><a href="#强缓存" class="header-anchor">#</a> 强缓存</h3> <p>浏览器中的缓存作用分为两种情况，一种是需要发送<code>HTTP</code>请求，一种是不需要发送。</p> <p>首先是检查强缓存，这个阶段<code>不需要</code>发送HTTP请求。</p> <p>如何来检查呢？通过相应的字段来进行，但是说起这个字段就有点门道了。</p> <p>在<code>HTTP/1.0</code>和<code>HTTP/1.1</code>当中，这个字段是不一样的。在早期，也就是<code>HTTP/1.0</code>时期，使用的是<strong>Expires</strong>，而<code>HTTP/1.1</code>使用的是<strong>Cache-Control</strong>。让我们首先来看看Expires。</p> <h4 id="expires"><a href="#expires" class="header-anchor">#</a> Expires</h4> <p><code>Expires</code>即过期时间，存在于服务端返回的响应头中，告诉浏览器在这个过期时间之前可以直接从缓存里面获取数据，无需再次请求。比如下面这样:</p> <div class="language- extra-class"><pre class="language-text"><code>Expires: Wed, 22 Nov 2019 08:41:00 GMT
复制代码
</code></pre></div><p>表示资源在<code>2019年11月22号8点41分</code>过期，过期了就得向服务端发请求。</p> <p>这个方式看上去没什么问题，合情合理，但其实潜藏了一个坑，那就是<strong>服务器的时间和浏览器的时间可能并不一致</strong>，那服务器返回的这个过期时间可能就是不准确的。因此这种方式很快在后来的HTTP1.1版本中被抛弃了。</p> <h4 id="cache-control"><a href="#cache-control" class="header-anchor">#</a> Cache-Control</h4> <p>在HTTP1.1中，采用了一个非常关键的字段：<code>Cache-Control</code>。这个字段也是存在于</p> <p>它和<code>Expires</code>本质的不同在于它并没有采用<code>具体的过期时间点</code>这个方式，而是采用过期时长来控制缓存，对应的字段是<strong>max-age</strong>。比如这个例子:</p> <div class="language- extra-class"><pre class="language-text"><code>Cache-Control:max-age=3600
复制代码
</code></pre></div><p>代表这个响应返回后在 3600 秒，也就是一个小时之内可以直接使用缓存。</p> <p>如果你觉得它只有<code>max-age</code>一个属性的话，那就大错特错了。</p> <p>它其实可以组合非常多的指令，完成更多场景的缓存判断, 将一些关键的属性列举如下: <strong>public</strong>: 客户端和代理服务器都可以缓存。因为一个请求可能要经过不同的<code>代理服务器</code>最后才到达目标服务器，那么结果就是不仅仅浏览器可以缓存数据，中间的任何代理节点都可以进行缓存。</p> <p><strong>private</strong>： 这种情况就是只有浏览器能缓存了，中间的代理服务器不能缓存。</p> <p><strong>no-cache</strong>: 跳过当前的强缓存，发送HTTP请求，即直接进入<code>协商缓存阶段</code>。</p> <p><strong>no-store</strong>：非常粗暴，不进行任何形式的缓存。</p> <p><strong>s-maxage</strong>：这和<code>max-age</code>长得比较像，但是区别在于s-maxage是针对代理服务器的缓存时间。</p> <p>值得注意的是，当<strong>Expires</strong>和<strong>Cache-Control</strong>同时存在的时候，<strong>Cache-Control</strong>会优先考虑。</p> <p>当然，还存在一种情况，当资源缓存时间超时了，也就是<code>强缓存</code>失效了，接下来怎么办？没错，这样就进入到第二级屏障——<strong>协商缓存</strong>了。</p> <h3 id="协商缓存"><a href="#协商缓存" class="header-anchor">#</a> 协商缓存</h3> <p>强缓存失效之后，浏览器在请求头中携带相应的<code>缓存tag</code>来向服务器发请求，由服务器根据这个tag，来决定是否使用缓存，这就是<strong>协商缓存</strong>。</p> <p>具体来说，这样的缓存tag分为两种: <strong>Last-Modified</strong> 和 <strong>ETag</strong>。这两者各有优劣，并不存在谁对谁有<code>绝对的优势</code>，跟上面强缓存的两个 tag 不一样。</p> <h4 id="last-modified"><a href="#last-modified" class="header-anchor">#</a> Last-Modified</h4> <p>即最后修改时间。在浏览器第一次给服务器发送请求后，服务器会在响应头中加上这个字段。</p> <p>浏览器接收到后，如果再次请求，会在请求头中携带<code>If-Modified-Since</code>字段，这个字段的值也就是服务器传来的最后修改时间。</p> <p>服务器拿到请求头中的<code>If-Modified-Since</code>的字段后，其实会和这个服务器中<code>该资源的最后修改时间</code>对比:</p> <ul><li>如果请求头中的这个值小于最后修改时间，说明是时候更新了。返回新的资源，跟常规的HTTP请求响应的流程一样。</li> <li>否则返回304，告诉浏览器直接用缓存。</li></ul> <h4 id="etag"><a href="#etag" class="header-anchor">#</a> ETag</h4> <p><code>ETag</code> 是服务器根据当前文件的内容，给文件生成的唯一标识，只要里面的内容有改动，这个值就会变。服务器通过<code>响应头</code>把这个值给浏览器。</p> <p>浏览器接收到<code>ETag</code>的值，会在下次请求时，将这个值作为<strong>If-None-Match</strong>这个字段的内容，并放到请求头中，然后发给服务器。</p> <p>服务器接收到<strong>If-None-Match</strong>后，会跟服务器上该资源的<strong>ETag</strong>进行比对:</p> <ul><li>如果两者不一样，说明要更新了。返回新的资源，跟常规的HTTP请求响应的流程一样。</li> <li>否则返回304，告诉浏览器直接用缓存。</li></ul> <h4 id="两者对比"><a href="#两者对比" class="header-anchor">#</a> 两者对比</h4> <ol><li>在<code>精准度</code>上，<code>ETag</code>优于<code>Last-Modified</code>。优于 ETag 是按照内容给资源上标识，因此能准确感知资源的变化。而 Last-Modified 就不一样了，它在一些特殊的情况并不能准确感知资源变化，主要有两种情况:</li></ol> <ul><li>编辑了资源文件，但是文件内容并没有更改，这样也会造成缓存失效。</li> <li>Last-Modified 能够感知的单位时间是秒，如果文件在 1 秒内改变了多次，那么这时候的 Last-Modified 并没有体现出修改了。</li></ul> <ol><li>在性能上，<code>Last-Modified</code>优于<code>ETag</code>，也很简单理解，<code>Last-Modified</code>仅仅只是记录一个时间点，而 <code>Etag</code>需要根据文件的具体内容生成哈希值。</li></ol> <p>另外，如果两种方式都支持的话，服务器会优先考虑<code>ETag</code>。</p> <h3 id="缓存位置"><a href="#缓存位置" class="header-anchor">#</a> 缓存位置</h3> <p>前面我们已经提到，当<code>强缓存</code>命中或者协商缓存中服务器返回304的时候，我们直接从缓存中获取资源。那这些资源究竟缓存在什么位置呢？</p> <p>浏览器中的缓存位置一共有四种，按优先级从高到低排列分别是：</p> <ul><li>Service Worker</li> <li>Memory Cache</li> <li>Disk Cache</li> <li>Push Cache</li></ul> <h3 id="service-worker"><a href="#service-worker" class="header-anchor">#</a> Service Worker</h3> <p>Service Worker 借鉴了 Web Worker的 思路，即让 JS 运行在主线程之外，由于它脱离了浏览器的窗体，因此无法直接访问<code>DOM</code>。虽然如此，但它仍然能帮助我们完成很多有用的功能，比如<code>离线缓存</code>、<code>消息推送</code>和<code>网络代理</code>等功能。其中的<code>离线缓存</code>就是 <strong>Service Worker Cache</strong>。</p> <p>Service Worker 同时也是 PWA 的重要实现机制，关于它的细节和特性，我们将会在后面的 PWA 的分享中详细介绍。</p> <h3 id="memory-cache-和-disk-cache"><a href="#memory-cache-和-disk-cache" class="header-anchor">#</a> Memory Cache 和 Disk Cache</h3> <p><strong>Memory Cache</strong>指的是内存缓存，从效率上讲它是最快的。但是从存活时间来讲又是最短的，当渲染进程结束后，内存缓存也就不存在了。</p> <p><strong>Disk Cache</strong>就是存储在磁盘中的缓存，从存取效率上讲是比内存缓存慢的，但是他的优势在于存储容量和存储时长。稍微有些计算机基础的应该很好理解，就不展开了。</p> <p>好，现在问题来了，既然两者各有优劣，那浏览器如何决定将资源放进内存还是硬盘呢？主要策略如下：</p> <ul><li>比较大的JS、CSS文件会直接被丢进磁盘，反之丢进内存</li> <li>内存使用率比较高的时候，文件优先进入磁盘</li></ul> <h3 id="push-cache"><a href="#push-cache" class="header-anchor">#</a> Push Cache</h3> <p>即推送缓存，这是浏览器缓存的最后一道防线。它是 <code>HTTP/2</code> 中的内容，虽然现在应用的并不广泛，但随着 HTTP/2 的推广，它的应用越来越广泛。关于 Push Cache，有非常多的内容可以挖掘，不过这已经不是本文的重点，大家可以参考这篇<a href="https://jakearchibald.com/2017/h2-push-tougher-than-i-thought/" target="_blank" rel="noopener noreferrer">扩展文章<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>。</p> <h3 id="总结"><a href="#总结" class="header-anchor">#</a> 总结</h3> <p>对浏览器的缓存机制来做个简要的总结:</p> <p>首先通过 <code>Cache-Control</code> 验证强缓存是否可用</p> <ul><li><p>如果强缓存可用，直接使用</p></li> <li><p>否则进入协商缓存，即发送 HTTP 请求，服务器通过请求头中的</p> <div class="language- extra-class"><pre class="language-text"><code>Last-Modified
</code></pre></div><p>或者</p> <div class="language- extra-class"><pre class="language-text"><code>ETag
</code></pre></div><p>字段检查资源是否更新</p> <ul><li>若资源更新，返回资源和200状态码</li> <li>否则，返回304，告诉浏览器直接从缓存获取资源</li></ul></li></ul> <h2 id="第十五题、js数据类型之问-检测篇"><a href="#第十五题、js数据类型之问-检测篇" class="header-anchor">#</a> 第十五题、JS数据类型之问--检测篇</h2> <h3 id="_1、typpeof-是否能正确判断类型"><a href="#_1、typpeof-是否能正确判断类型" class="header-anchor">#</a> 1、typpeof 是否能正确判断类型？</h3> <p>对于原始类型来说，除了 null 都可以调用typeof显示正确的类型。</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">typeof</span> <span class="token number">1</span> <span class="token comment">// 'number'</span>
<span class="token keyword">typeof</span> <span class="token string">'1'</span> <span class="token comment">// 'string'</span>
<span class="token keyword">typeof</span> <span class="token keyword">undefined</span> <span class="token comment">// 'undefined'</span>
<span class="token keyword">typeof</span> <span class="token boolean">true</span> <span class="token comment">// 'boolean'</span>
<span class="token keyword">typeof</span> <span class="token function">Symbol</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 'symbol'</span>

</code></pre></div><p>但对于引用数据类型，除了函数之外，都会显示&quot;object&quot;。</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">typeof</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token comment">// 'object'</span>
<span class="token keyword">typeof</span> <span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token comment">// 'object'</span>
<span class="token keyword">typeof</span> console<span class="token punctuation">.</span>log <span class="token comment">// 'function'</span>
</code></pre></div><p>因此采用typeof判断对象数据类型是不合适的，采用instanceof会更好，instanceof的原理是基于原型链的查询，只要处于原型链中，判断永远为true</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">const</span> <span class="token function-variable function">Person</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token keyword">const</span> p1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
p1 <span class="token keyword">instanceof</span> <span class="token class-name">Person</span> <span class="token comment">// true</span>

<span class="token keyword">var</span> str1 <span class="token operator">=</span> <span class="token string">'hello world'</span>
str1 <span class="token keyword">instanceof</span> <span class="token class-name">String</span> <span class="token comment">// false</span>

<span class="token keyword">var</span> str2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">'hello world'</span><span class="token punctuation">)</span>
str2 <span class="token keyword">instanceof</span> <span class="token class-name">String</span> <span class="token comment">// true</span>

</code></pre></div><h3 id="_2、instanceof能否判断基本数据类型"><a href="#_2、instanceof能否判断基本数据类型" class="header-anchor">#</a> 2、instanceof能否判断基本数据类型？</h3> <p>能。比如下面这种方式:</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">class</span> <span class="token class-name">PrimitiveNumber</span> <span class="token punctuation">{</span>
  <span class="token keyword">static</span> <span class="token punctuation">[</span>Symbol<span class="token punctuation">.</span>hasInstance<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token parameter">x</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">typeof</span> x <span class="token operator">===</span> <span class="token string">'number'</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">111</span> <span class="token keyword">instanceof</span> <span class="token class-name">PrimitiveNumber</span><span class="token punctuation">)</span> <span class="token comment">// true</span>

</code></pre></div><p>如果你不知道Symbol，可以看看<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Symbol/hasInstance" target="_blank" rel="noopener noreferrer">MDN上关于hasInstance的解释<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>。</p> <p>其实就是自定义instanceof行为的一种方式，这里将原有的instanceof方法重定义，换成了typeof，因此能够判断基本数据类型。</p> <h3 id="_3-能不能手动实现一下instanceof的功能"><a href="#_3-能不能手动实现一下instanceof的功能" class="header-anchor">#</a> 3. 能不能手动实现一下instanceof的功能？</h3> <p>核心: 原型链的向上查找。</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">myInstanceof</span><span class="token punctuation">(</span><span class="token parameter">left<span class="token punctuation">,</span>right</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token comment">// 基本数据类型直接返回 false</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> left<span class="token operator">!==</span><span class="token string">'object'</span><span class="token operator">||</span>left<span class="token operator">===</span><span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
    <span class="token comment">// getProtypeOf 是Object对象自带的一个方法，能够拿到参数的原型对象</span>
    <span class="token keyword">let</span> proto <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">getPrototypeOf</span><span class="token punctuation">(</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token comment">// 查找到尽头，还没找到</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>proto<span class="token operator">===</span><span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span>
        <span class="token comment">// 找到相同的原型对象</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>proto<span class="token operator">==</span>right<span class="token punctuation">.</span>prototype<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">true</span>
        proto <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">getPrototypeOf</span><span class="token punctuation">(</span>proto<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>测试：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">myInstanceof</span><span class="token punctuation">(</span><span class="token string">&quot;111&quot;</span><span class="token punctuation">,</span> String<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//false</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">myInstanceof</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">&quot;111&quot;</span><span class="token punctuation">)</span><span class="token punctuation">,</span> String<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//true</span>

</code></pre></div><h3 id="_4、object-is和-的区别"><a href="#_4、object-is和-的区别" class="header-anchor">#</a> 4、Object.is和===的区别？</h3> <p>Object在严格等于的基础上修复了一些特殊情况下的失误，具体来说就是+0和-0，NaN和NaN。 源码如下：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code>
<span class="token keyword">function</span> <span class="token function">is</span><span class="token punctuation">(</span><span class="token parameter">x<span class="token punctuation">,</span> y</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">===</span> y<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">//运行到1/x === 1/y的时候x和y都为0，但是1/+0 = +Infinity， 1/-0 = -Infinity, 是不一样的</span>
    <span class="token keyword">return</span> x <span class="token operator">!==</span> <span class="token number">0</span> <span class="token operator">||</span> y <span class="token operator">!==</span> <span class="token number">0</span> <span class="token operator">||</span> <span class="token number">1</span> <span class="token operator">/</span> x <span class="token operator">===</span> <span class="token number">1</span> <span class="token operator">/</span> y<span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token comment">//NaN===NaN是false,这是不对的，我们在这里做一个拦截，x !== x，那么一定是 NaN, y 同理</span>
    <span class="token comment">//两个都是NaN的时候返回true</span>
    <span class="token keyword">return</span> x <span class="token operator">!==</span> x <span class="token operator">&amp;&amp;</span> y <span class="token operator">!==</span> y<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
 
</code></pre></div><h2 id="第十六题、js数据类型之问-转换篇"><a href="#第十六题、js数据类型之问-转换篇" class="header-anchor">#</a> 第十六题、JS数据类型之问--转换篇</h2> <h3 id="_1、-结果是什么-为什么"><a href="#_1、-结果是什么-为什么" class="header-anchor">#</a> 1、[] == ![] 结果是什么？为什么？</h3> <blockquote><p>解析</p></blockquote> <p>== 中，左右两边都需要转换为数字然后进行比较。</p> <p>[] 转换为数字为 0</p> <p>![] 首先是转换为布尔值，由于 [] 作为一个引用类型转换为布尔值为 true</p> <p>因此 <strong>![]</strong> 为 false， 进而再转换为数字，变为 0</p> <p>0==0，结果为 true</p> <h3 id="_2、js-中类型转换有哪几种"><a href="#_2、js-中类型转换有哪几种" class="header-anchor">#</a> 2、js 中类型转换有哪几种？</h3> <p>JS 中，类型转换只有三种</p> <ul><li>转换成数字</li> <li>转换成布尔值</li> <li>转换成字符串</li></ul> <p>转换具体规则如下：</p> <blockquote><p>注意&quot;Boolean 转字符串&quot;这行结果指的是 true 转字符串的例子</p></blockquote> <table><thead><tr><th><strong>原始值</strong></th> <th><strong>转换目标</strong></th> <th><strong>结果</strong></th></tr></thead> <tbody><tr><td>number</td> <td>布尔值</td> <td>除了0、-0、NaN 外都为 true</td></tr> <tr><td>string</td> <td>布尔值</td> <td>除了空字符串都为true</td></tr> <tr><td>undefined、null</td> <td>布尔值</td> <td>False</td></tr> <tr><td>引用类型</td> <td>布尔值</td> <td>true</td></tr> <tr><td>number</td> <td>字符串</td> <td>5 =&gt; '5'</td></tr> <tr><td>Boolean、函数、Symbol</td> <td>字符串</td> <td>‘true’</td></tr> <tr><td>数组</td> <td>字符串</td> <td>[1,2] =&gt; '1,2'</td></tr> <tr><td>对象</td> <td>字符串</td> <td>‘[object Object]’</td></tr> <tr><td>string</td> <td>数字</td> <td>‘1’ =&gt; 1, 'a' =&gt; NaN</td></tr> <tr><td>数组</td> <td>数字</td> <td>空数组为0，存在一个元素且为数字转数字，其他情况NaN</td></tr> <tr><td>null</td> <td>数字</td> <td>0</td></tr> <tr><td>undefined</td> <td>数字</td> <td>NaN</td></tr> <tr><td>除了数组的引用类型</td> <td>数字</td> <td>NaN</td></tr> <tr><td>Symbol</td> <td>数字</td> <td>抛错</td></tr></tbody></table> <h3 id="_3、-和-有什么区别"><a href="#_3、-和-有什么区别" class="header-anchor">#</a> 3、== 和 === 有什么区别？</h3> <blockquote><p>=== 叫做严格相等，是指：左右两边不仅值要相等，类型也要相等，例如 ‘1’===1 的结果为 false,因为一边为 string,另一边为 number</p></blockquote> <p>==不像===那样严格，对于一般情况，只要值相等，就返回true，但==还涉及一些类型转换，它的转换规则如下：</p> <ul><li>两边的类型是否相同，相同的话就比较值的大小，例如1==2，返回false</li> <li>判断的是否是null和undefined，是的话就返回true</li> <li>判断的类型是否是String和Number，是的话，把String类型转换成Number，再进行比较</li> <li>判断其中一方是否是Boolean，是的话就把Boolean转换成Number，再进行比较</li> <li>如果其中一方为Object，且另一方为String、Number或者Symbol，会将Object转换成字符串，再进行比较</li></ul> <div class="language-javascript extra-class"><pre class="language-javascript"><code>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token literal-property property">a</span><span class="token operator">:</span><span class="token number">1</span><span class="token punctuation">}</span><span class="token operator">==</span><span class="token boolean">true</span><span class="token punctuation">)</span>			<span class="token comment">// false</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token literal-property property">a</span><span class="token operator">:</span><span class="token number">1</span><span class="token punctuation">}</span><span class="token operator">==</span><span class="token string">&quot;[object Object]&quot;</span><span class="token punctuation">)</span>		<span class="token comment">// true</span>
</code></pre></div><h3 id="_4、对象转原始类型是根据什么流程运行的"><a href="#_4、对象转原始类型是根据什么流程运行的" class="header-anchor">#</a> 4、对象转原始类型是根据什么流程运行的</h3> <p>对象转原始类型，会调用内置的[ToPrimitive]函数，对于该函数而言，其逻辑如下：</p> <p>1、如果Symbol.toPtimitive() 方法，优先调用再返回</p> <p>2、调用valueOf(), 如果转换为原始类型，则返回</p> <p>3、调用toString()，如果转换为原始类型，则返回</p> <p>4、如果都没有返回原始类型，会报错</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token literal-property property">value</span><span class="token operator">:</span><span class="token number">3</span><span class="token punctuation">,</span>
    <span class="token function">valueOf</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token number">4</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token string">'5'</span>
    <span class="token punctuation">}</span>
    <span class="token punctuation">[</span>Symbol<span class="token punctuation">.</span>toPrimitive<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token number">6</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>obj<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>				<span class="token comment">// 输出 7</span>
</code></pre></div><h3 id="_5、如何让-if-a-1-a-2-条件成立"><a href="#_5、如何让-if-a-1-a-2-条件成立" class="header-anchor">#</a> 5、如何让 if(a==1&amp;&amp;a==2) 条件成立</h3> <p>其实就是上一个问题的应用</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token literal-property property">value</span><span class="token operator">:</span><span class="token number">0</span><span class="token punctuation">,</span>
    <span class="token function-variable function">valueOf</span><span class="token operator">:</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>value<span class="token operator">++</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>value
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token operator">==</span><span class="token number">1</span><span class="token operator">&amp;&amp;</span>a<span class="token operator">==</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>		<span class="token comment">// true</span>
</code></pre></div><h2 id="第十七题-var-为什么会被let-取代"><a href="#第十七题-var-为什么会被let-取代" class="header-anchor">#</a> 第十七题：var 为什么会被let 取代</h2> <p>先看 用到 var 的一段代码</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">doSomething</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">5</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'Finally '</span> <span class="token operator">+</span> i<span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token function">doSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre></div><p>打印结果：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token number">0</span>
<span class="token number">1</span>
<span class="token number">2</span>
<span class="token number">3</span>
<span class="token number">4</span>
Finally <span class="token number">5</span>
</code></pre></div><p>i 在 for 语句里定义的，为什么在 for 语句外面仍然打印出来值了呢？？</p> <p>再看用到 let 的一段代码。</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">doSomething</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">5</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'Finally '</span> <span class="token operator">+</span> i<span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token function">doSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre></div><p>打印结果如下：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token number">0</span>
<span class="token number">1</span>
<span class="token number">2</span>
<span class="token number">3</span>
<span class="token number">4</span>
Uncaught ReferenceError<span class="token operator">:</span> i is not defined
    at <span class="token function">doSomething</span> <span class="token punctuation">(</span><span class="token operator">&lt;</span>anonymous<span class="token operator">&gt;</span><span class="token operator">:</span><span class="token number">5</span><span class="token operator">:</span><span class="token number">30</span><span class="token punctuation">)</span>
    at <span class="token operator">&lt;</span>anonymous<span class="token operator">&gt;</span><span class="token operator">:</span><span class="token number">8</span><span class="token operator">:</span><span class="token number">1</span>
</code></pre></div><p>let 定义的变量 i 符合我们的常识，i 的作用域只在 for 语句里，在 for 外部用 i 变量报错未定义。</p> <p>结论：</p> <ul><li>let 和 const 定义变量的作用域都是 <strong>离变量最近的那个块</strong> 内；</li> <li>var 定义变量的作用域是 <strong>离变量最近的那个方法</strong> 内。上面，用 var 定义的 i 变量的作用域为离 i 最近的方法内，即 i 的作用域在 doSomething 内，所以在 for 语句外也能打印出 i 的值。</li></ul> <h2 id="第十八题、谈谈你对闭包的理解"><a href="#第十八题、谈谈你对闭包的理解" class="header-anchor">#</a> 第十八题、谈谈你对闭包的理解</h2> <h3 id="什么时闭包"><a href="#什么时闭包" class="header-anchor">#</a> 什么时闭包？</h3> <blockquote><p>红宝书(js高级程序设计p178)上对于闭包的定义：闭包是指有权访问另外一个函数作用域中的变量的函数，</p></blockquote> <blockquote><p>MDN 对闭包的定义为：闭包是指那些能够访问自由变量的函数。 （其中自由变量，指在函数中使用的，但既不是函数参数arguments也不是函数的局部变量的变量，其实就是另外一个函数作用域中的变量。）</p></blockquote> <h3 id="闭包产生的原因"><a href="#闭包产生的原因" class="header-anchor">#</a> 闭包产生的原因</h3> <p>首先要明白作用域链的概念，其实很简单，在ES5中只存在两种作用域----全局作用域和函数作用域</p> <p><font color="red">当访问一个变量时，解释器会首先在当前作用域查找标识符，如果没有找到，就去父作用域找，直到找到该变量的标识符或者不再父作用域中，这就是作用域链</font></p> <p>值得注意的时，每个子函数都会拷贝上级的作用域，形成一个作用域的链条。比如</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">1</span>

<span class="token keyword">function</span> <span class="token function">f1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">2</span>
    <span class="token keyword">function</span> <span class="token function">f2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>		<span class="token comment">//3</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>在这段代码中，f1的作用域指向有全局作用域(window)和它本身，而f2的作用域指向全局作用域(window)、f1和它本身。而且作用域是从最底层向上找，直到找到全局作用域window为止，如果全局还没有的话就会报错。就这么简单一件事情！</p> <p><font color="red">闭包产生的本质就是，当前环境中存在指向父级作用域的引用</font>，还是举上面的例子：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">f1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">2</span>
    <span class="token keyword">function</span> <span class="token function">f2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> f2
<span class="token punctuation">}</span>


<span class="token keyword">var</span> x <span class="token operator">=</span> <span class="token function">f1</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

<span class="token function">x</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>	<span class="token comment">// 2</span>

</code></pre></div><p>这里x会拿到父级作用域中的变量，输出2。因为在当前环境中，含有对f2的引用，f2恰恰引用了window、f1和f2的作用域。因此f2可以访问到f1的作用域的变量。</p> <p>那是不是只有返回函数才算是产生了闭包呢？、</p> <p>回到闭包的本质，我们只需要让父级作用域的引用存在即可，因此我们还可以这么做：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">var</span> f3<span class="token punctuation">;</span>
<span class="token keyword">function</span> <span class="token function">f1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">var</span> a<span class="token operator">=</span><span class="token number">2</span>
    <span class="token function-variable function">f3</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token function">f1</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token function">f3</span><span class="token punctuation">(</span><span class="token punctuation">)</span>		<span class="token comment">// 2</span>
</code></pre></div><p>让f1执行，给f3赋值后，等于说现在<code>f3拥有了window、f1和f3本身这几个作用域的访问权限</code>，还是自底向上查找，<code>最近是在f1</code>中找到了a,因此输出2。</p> <p>在这里是外面的变量<code>f3存在着父级作用域的引用</code>，因此产生了闭包，形式变了，本质没有改变。</p> <h3 id="闭包有哪些表现形式"><a href="#闭包有哪些表现形式" class="header-anchor">#</a> 闭包有哪些表现形式</h3> <p>明白了本质之后，我们就来看看，在真实的场景中，究竟在哪些地方能体现闭包的存在？</p> <ul><li>返回一个函数，上面的例子就是这种形式</li> <li>作为函数参数传递</li></ul> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">1</span>
<span class="token keyword">function</span> <span class="token function">foo</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">2</span>
    <span class="token keyword">function</span> <span class="token function">baz</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    <span class="token function">bar</span><span class="token punctuation">(</span>baz<span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">bar</span><span class="token punctuation">(</span><span class="token parameter">fn</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token comment">// 这就是闭包</span>
    <span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token comment">// 输出2，而不是1</span>
<span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

</code></pre></div><ul><li>在定时器、事件监听、ajax请求、跨窗口通信、Web Workers 或者任何异步中，只要使用了回调函数，实际上就是在使用闭包</li></ul> <p>以下的闭包保存的仅仅时 window 和 当前作用域</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token comment">// 定时器</span>
<span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token function">timeHandler</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'111'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>，<span class="token number">100</span><span class="token punctuation">)</span>

<span class="token comment">// 事件监听</span>
<span class="token function">$</span><span class="token punctuation">(</span><span class="token string">'#app'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">click</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'DOM Listener'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>

</code></pre></div><ul><li>IIFE(立即执行函数表达式)创建闭包，保存了全局作用与window 和当前函数的作用域，因此可以全局的变量</li></ul> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">2</span>
<span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token constant">IIFE</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token comment">// 输出2 </span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre></div><h3 id="如何解决下面的循环输出问题"><a href="#如何解决下面的循环输出问题" class="header-anchor">#</a> 如何解决下面的循环输出问题？</h3> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">var</span> i<span class="token operator">=</span>i<span class="token punctuation">;</span>i<span class="token operator">&lt;=</span><span class="token number">5</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token function">timer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><p>为什么会全部输出6？如何改进，让它输出1，2，3，4，5？(方法越多越好)</p> <p>因为setTimeout为宏任务，由于JS中单线程eventLoop机制，在主线程同步任务执行完后才去执行宏任务，因此循环结束后setTimeout中的回调才依次执行，但输出i的时候当前作用域没有，往上一级再找，发现了i,此时循环已经结束，i变成了6。因此会全部输出6。</p> <p>解决方法：</p> <ul><li>1、理由IIFE（立即执行函数表达式）当每次for循环时，把</li></ul> <p>此时的i变量传递到定时器中</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">var</span> u<span class="token operator">=</span>i<span class="token punctuation">;</span>i<span class="token operator">&lt;=</span><span class="token number">5</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">j</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token function">timer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
            console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span>
        <span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><ul><li>2、给定时器传入第三个参数，作为 timer 函数的第一个函数参数</li></ul> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">var</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span><span class="token number">5</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token function">timer</span><span class="token punctuation">(</span><span class="token parameter">j</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span>i<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><ul><li>3、使用ES6中的let</li></ul> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span><span class="token number">5</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token function">timer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><p>let使JS发生革命性的变化，让JS有函数作用域变为了块级作用域，用let后作用域链不复存在。代码的作用域以块级为单位，以上面代码为例:</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token comment">// i = 1</span>
<span class="token punctuation">{</span>
  <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token function">timer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token comment">// i = 2</span>
<span class="token punctuation">{</span>
  <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token function">timer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token comment">// i = 3</span>
<span class="token operator">...</span>

</code></pre></div><p>因此能输出正确的结果。</p> <h2 id="第十九题、实现一个-storage"><a href="#第十九题、实现一个-storage" class="header-anchor">#</a> 第十九题、实现一个 Storage</h2> <p>描述：</p> <p>:::info</p> <p>实现 Storage ，使得该对象为单例，基于 localStorage 进行封装。实现方法 setItem(key,value) 和 getItem(key)</p> <p>:::</p> <p>思路：  拿到单例模式相关的面试题，大家首先要做的说就是回忆 单例模式的 基本实现思路，一个 <strong>具备判断自己是否已经创建过一个实例</strong> 的构造函数</p> <blockquote><p>静态方法版</p></blockquote> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token comment">// 定义Storage</span>
<span class="token keyword">class</span> <span class="token class-name">Storage</span><span class="token punctuation">{</span>
    <span class="token keyword">static</span> <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token comment">// 判断是否已经 new 过实例</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>Storage<span class="token punctuation">.</span>instance<span class="token punctuation">)</span><span class="token punctuation">{</span>
            <span class="token comment">// 若这个唯一的实例不存在，那么先创建它</span>
            Storage<span class="token punctuation">.</span>instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Storage</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
        <span class="token comment">// 如果这个唯一的实例已经存在，则直接返回</span>
        <span class="token keyword">return</span> Storage<span class="token punctuation">.</span>instance
    <span class="token punctuation">}</span>
    
    <span class="token function">getItem</span><span class="token punctuation">(</span><span class="token parameter">key</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">return</span> localStorage<span class="token punctuation">.</span><span class="token function">getItem</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    
    <span class="token function">setItem</span><span class="token punctuation">(</span><span class="token parameter">key，value</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">return</span> localStorage<span class="token punctuation">.</span><span class="token function">setItem</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span>value<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>


<span class="token keyword">const</span> storage1 <span class="token operator">=</span> Storage<span class="token punctuation">.</span><span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">const</span> storage2 <span class="token operator">=</span> Storage<span class="token punctuation">.</span><span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

<span class="token comment">// 李雷</span>
storage1<span class="token punctuation">.</span><span class="token function">setItem</span><span class="token punctuation">(</span><span class="token string">'name'</span><span class="token punctuation">,</span><span class="token string">'李雷'</span><span class="token punctuation">)</span>

storage1<span class="token punctuation">.</span><span class="token function">getItem</span><span class="token punctuation">(</span><span class="token string">'name'</span><span class="token punctuation">)</span>		<span class="token comment">// 李雷</span>

storage2<span class="token punctuation">.</span><span class="token function">getItem</span><span class="token punctuation">(</span><span class="token string">'name'</span><span class="token punctuation">)</span>		<span class="token comment">// 李雷</span>

storage1 <span class="token operator">===</span> storage2			<span class="token comment">// true</span>
</code></pre></div><blockquote><p>实现 闭包版</p></blockquote> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token comment">// 先实现一个基础的 StorageBase 类 ， 把  getItem 和 setItem 方法放在它的原型链上</span>
<span class="token keyword">function</span> <span class="token function">StorageBase</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>

<span class="token class-name">StorageBase</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">getItem</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">key</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">return</span> localStorage<span class="token punctuation">.</span><span class="token function">getItem</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token class-name">StorageBase</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">setItem</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">key<span class="token punctuation">,</span>value</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">return</span> localStorage<span class="token punctuation">.</span><span class="token function">setItem</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span>value<span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token comment">// 以闭包的形式创建一个引用自由变量的构造函数</span>
<span class="token keyword">const</span> Storage <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">let</span> instance <span class="token operator">=</span> <span class="token keyword">null</span>
    <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token comment">// 判断自由变量是否为 null</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>instance<span class="token punctuation">)</span><span class="token punctuation">{</span>
            <span class="token comment">// 如果为 null 则 new 出唯一实例</span>
            instance  <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StorageBase</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> instance
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span>


<span class="token comment">// 这里其实不用 new  Storage 的形式调用，直接 Storage() 也会有一样的效果</span>
<span class="token keyword">const</span> storage1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Storage</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">const</span> storage2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Storage</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

storage1<span class="token punctuation">.</span><span class="token function">setItem</span><span class="token punctuation">(</span><span class="token string">'name'</span><span class="token punctuation">,</span><span class="token string">'韩梅梅'</span><span class="token punctuation">)</span>

storage1<span class="token punctuation">.</span><span class="token function">getItem</span><span class="token punctuation">(</span><span class="token string">'name'</span><span class="token punctuation">)</span>		<span class="token comment">// 韩梅梅</span>
storege2<span class="token punctuation">.</span><span class="token function">getItem</span><span class="token punctuation">(</span><span class="token string">'name'</span><span class="token punctuation">)</span>		<span class="token comment">// 韩梅梅</span>

storage1 <span class="token operator">===</span> storage2		<span class="token comment">// true</span>

</code></pre></div><h2 id="第二十题、实现一个全局的模态框"><a href="#第二十题、实现一个全局的模态框" class="header-anchor">#</a> 第二十题、实现一个全局的模态框</h2> <p>描述：</p> <p>:::info</p> <p>实现一个全局唯一的Modal 弹窗</p> <p>:::</p> <p>思路：</p> <p>这道题比较经典，基本上所有讲解单例模式的文章都会以此为例，同时它也是早期 单例模式 在前端领域的最集中体现。</p> <p>实现：</p> <div class="language-html extra-class"><pre class="language-html"><code><span class="token doctype"><span class="token punctuation">&lt;!</span><span class="token doctype-tag">DOCTYPE</span> <span class="token name">html</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span> <span class="token attr-name">lang</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>en<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">charset</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>UTF-8<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">&gt;</span></span>单例模式弹框<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span><span class="token punctuation">&gt;</span></span><span class="token style"><span class="token language-css">
    <span class="token selector">#modal</span> <span class="token punctuation">{</span>
        <span class="token property">height</span><span class="token punctuation">:</span> 200px<span class="token punctuation">;</span>
        <span class="token property">width</span><span class="token punctuation">:</span> 200px<span class="token punctuation">;</span>
        <span class="token property">line-height</span><span class="token punctuation">:</span> 200px<span class="token punctuation">;</span>
        <span class="token property">position</span><span class="token punctuation">:</span> fixed<span class="token punctuation">;</span>
        <span class="token property">left</span><span class="token punctuation">:</span> 50%<span class="token punctuation">;</span>
        <span class="token property">top</span><span class="token punctuation">:</span> 50%<span class="token punctuation">;</span>
        <span class="token property">transform</span><span class="token punctuation">:</span> <span class="token function">translate</span><span class="token punctuation">(</span>-50%<span class="token punctuation">,</span> -50%<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token property">border</span><span class="token punctuation">:</span> 1px solid black<span class="token punctuation">;</span>
        <span class="token property">text-align</span><span class="token punctuation">:</span> center<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">&gt;</span></span>
	<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">'</span>open<span class="token punctuation">'</span></span><span class="token punctuation">&gt;</span></span>打开弹框<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">&gt;</span></span>
	<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">'</span>close<span class="token punctuation">'</span></span><span class="token punctuation">&gt;</span></span>关闭弹框<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">&gt;</span></span><span class="token script"><span class="token language-javascript">
  <span class="token comment">// 核心逻辑，这里采用了闭包思路来实现单例模式</span>
  <span class="token keyword">const</span> Modal <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
      <span class="token keyword">let</span> modal <span class="token operator">=</span> <span class="token keyword">null</span>
      <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
          <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>modal<span class="token punctuation">)</span><span class="token punctuation">{</span>
              modal <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">'div'</span><span class="token punctuation">)</span>
              modal<span class="token punctuation">.</span>innerHTML <span class="token operator">=</span> <span class="token string">'我是一个全局唯一的弹窗'</span>
              modal<span class="token punctuation">.</span>id <span class="token operator">=</span> <span class="token string">'modal'</span>
              modal<span class="token punctuation">.</span>style<span class="token punctuation">.</span>display <span class="token operator">=</span> <span class="token string">'none'</span>
              document<span class="token punctuation">.</span>body<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>modal<span class="token punctuation">)</span>
          <span class="token punctuation">}</span>
          <span class="token keyword">return</span> modal
      <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  
  <span class="token comment">// 点击打开按钮展示模态框</span>
  document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'open'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'click'</span><span class="token punctuation">,</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
      <span class="token comment">// 未点击则不创建 modal 实例，避免不必要的内存占用，此处不用 new Modal的形式也可以</span>
      <span class="token keyword">const</span> modal <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Modal</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
      modal<span class="token punctuation">.</span>style<span class="token punctuation">.</span>display <span class="token operator">=</span> <span class="token string">'block'</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
    
  <span class="token comment">// 点击关闭按钮隐藏模态框</span>
  document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'close'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'click'</span>，<span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
      <span class="token keyword">const</span> modal <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Modal</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
      modal<span class="token punctuation">.</span>style<span class="token punctuation">.</span>display <span class="token operator">=</span> <span class="token string">'none'</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>  
</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">&gt;</span></span>
</code></pre></div><h2 id="第二十一题-下面哪些值是假值"><a href="#第二十一题-下面哪些值是假值" class="header-anchor">#</a> 第二十一题：下面哪些值是假值</h2> <div class="language-javascript extra-class"><pre class="language-javascript"><code>
<span class="token number">0</span><span class="token punctuation">;</span>        <span class="token comment">// false</span>

<span class="token keyword">new</span> <span class="token class-name">Number</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">;</span>     <span class="token comment">// true</span>

<span class="token punctuation">(</span><span class="token string">''</span><span class="token punctuation">)</span>        <span class="token comment">// false</span>

<span class="token punctuation">(</span><span class="token string">'  '</span><span class="token punctuation">)</span>    <span class="token comment">// true</span>

<span class="token keyword">new</span> <span class="token class-name">Boolean</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span>    <span class="token comment">// true</span>

<span class="token keyword">undefined</span>       <span class="token comment">// false</span>

</code></pre></div><p>解析： Javascript 中只有 6个假值： <code>undefined</code>、<code>null</code>、<code>NaN</code>、<code>0</code>、<code>''</code>(empty string)、<code>false</code>
函数和构造函数和对象都是真值</p> <h2 id="第二十二题、-yield-和-generator"><a href="#第二十二题、-yield-和-generator" class="header-anchor">#</a> 第二十二题、 yield 和 generator</h2> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span><span class="token operator">*</span> <span class="token function">generatorOne</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">yield</span> <span class="token punctuation">[</span><span class="token string">'a'</span><span class="token punctuation">,</span><span class="token string">'b'</span><span class="token punctuation">,</span><span class="token string">'c'</span><span class="token punctuation">]</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span><span class="token operator">*</span> <span class="token function">generatorTwo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">yield</span><span class="token operator">*</span> <span class="token punctuation">[</span><span class="token string">'a'</span><span class="token punctuation">,</span><span class="token string">'b'</span><span class="token punctuation">,</span><span class="token string">'c'</span><span class="token punctuation">]</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> one <span class="token operator">=</span> <span class="token function">generatorOne</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">const</span> two <span class="token operator">=</span> <span class="token function">generatorTwo</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>one<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>value<span class="token punctuation">)</span>		<span class="token comment">// ['a','b','c']</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>two<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>value<span class="token punctuation">)</span>		<span class="token comment">// a</span>
</code></pre></div><p>通过 <code>yield</code> 关键字 ，我们在 <code>Generator</code> 函数里执行 <code>yeild</code> 表达式，通过<code>yield*</code> 关键字，我么可以在一个<code>Generator</code>函数里面执行 （<code>yield</code>表达式）另一个<code>Generator</code>函数，或可遍历的对象（如数组）</p> <p>在 <code>GeneratorOne</code>函数中，我们通过 <code>yield</code>关键字 yield 了一个完整的数组<code>['a','b','c']</code>。函数 <code>one</code>通过 <code>next</code>方法返回的对象的 <code>value</code>属性的只（<code>one.next().value</code>）等价于 <code>['a','b','c']</code></p> <div class="language-js extra-class"><pre class="language-js"><code>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>one<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>value<span class="token punctuation">)</span>		<span class="token comment">// ['a','b','c']</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>one<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>value<span class="token punctuation">)</span>		<span class="token comment">// undefined</span>
</code></pre></div><p>在函数 <code>generatorTwo</code>中，我们使用 <code>yield*</code>关键字，就相当于 函数 <code>tow</code> 第一个<code>yield</code>的值，等价于在迭代器中第一个 <code>yield</code>的值。数组 <code>['a','b','c']</code> 就是这个迭代器。第一个<code>yield</code>的值就是 <code>a</code>，所以我们第一次调用 <code>two.next().value</code>时，就返回 <code>a</code></p> <div class="language-js extra-class"><pre class="language-js"><code>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>two<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>value<span class="token punctuation">)</span>		<span class="token comment">// a</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>two<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>value<span class="token punctuation">)</span>		<span class="token comment">// b</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>two<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>value<span class="token punctuation">)</span>		<span class="token comment">// c</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>two<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>value<span class="token punctuation">)</span>		<span class="token comment">// undefined</span>
</code></pre></div><h2 id="第二十三题、双向绑定和vuex-是否冲突"><a href="#第二十三题、双向绑定和vuex-是否冲突" class="header-anchor">#</a> 第二十三题、双向绑定和vuex 是否冲突</h2> <p>当在严格模式中使用 <code>vuex</code>时，在属于<code>vuex</code>的<code>state</code>上使用<code>v-model</code>时会导致出错</p> <p>解决方案：</p> <ul><li>1、给<code>&lt;input&gt;</code> 中绑定value,然后侦听 <code>input</code>或者 <code>change</code>事件，在事件回调中调用一个方法</li> <li>2、使用带有<code>setter</code>的双向绑定计算属性</li></ul> <h2 id="第二十四题、关于const-和let-声明的变量为什么不在-window-上。"><a href="#第二十四题、关于const-和let-声明的变量为什么不在-window-上。" class="header-anchor">#</a> 第二十四题、关于const 和let 声明的变量为什么不在 window 上。</h2> <div class="language-javascript extra-class"><pre class="language-javascript"><code>
<span class="token keyword">const</span> o1 <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token literal-property property">name</span><span class="token operator">:</span><span class="token string">&quot;zs&quot;</span><span class="token punctuation">}</span>
<span class="token keyword">let</span> n1 <span class="token operator">=</span> <span class="token number">123</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>o1<span class="token punctuation">)</span>   <span class="token comment">// {name:&quot;zs&quot;}</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>n1<span class="token punctuation">)</span>   <span class="token comment">// 123</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>window<span class="token punctuation">.</span>o1<span class="token punctuation">)</span>  <span class="token comment">// undefined</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>window<span class="token punctuation">.</span>n1<span class="token punctuation">)</span>  <span class="token comment">// undefined</span>

</code></pre></div><p>javascript 在 ES6 提供 let 和 const 声明关键字之前是没有块级作用域的概念。如果需要实现块级作用域需要利用函数来实现。但在ES6 提供了let 和 const 声明关键字以后，Javascript就有了块级作用域的概念。通过 let 和 const 声明的变量，在指定块的作用于外无法被访问。块级作用域。</p> <p>块级作用域的理解可以拆分成两部分来理解：作用域、块级。</p> <ul><li>作用域：在运行时代码中的某些特定部分中变量，函数和对象的可访问性(也就是在代码执行时，能访问到的变量，函数和对象共同组合而成的一个集合)，决定代码区域中变量和其它资源的可见性。</li> <li>块级：javascript 中的块级就是 {...} 大括号内的代码块，我们称之为一个块级。</li></ul> <p>所以块级作用域就是包含在 {。。。}中的作用域。在这个作用域中,拥有着和函数作用域相同的行为。块级作用域不属于 全局作用域。全局环境下通过 let 和 const 声明变量处于script块级作用域中。</p> <p><img src="/assets/img/1592202861865.125aa348.png" alt="1592202861865"></p> <!----></div> <footer class="page-edit"><!----> <div class="last-updated"><span class="prefix">最后更新时间:</span> <span class="time">2/21/2022, 3:29:09 PM</span></div></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/frontend/advanced-前端埋点.html" class="prev">
        前端监控与埋点
      </a></span> <span class="next"><a href="/frontend/advanced-web前端面试题.html">
        刷面试
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"><!----></div></div>
    <script src="/assets/js/app.f8839a88.js" defer></script><script src="/assets/js/2.8d06e467.js" defer></script><script src="/assets/js/8.bda61152.js" defer></script>
  </body>
</html>

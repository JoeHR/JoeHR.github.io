<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>React 最新的生命周期是怎样的？ | 个人主页</title>
    <meta name="generator" content="VuePress 1.9.9">
    <link rel="icon" href="/img/logo.ico">
    <link rel="apple-touch-icon" href="/img/logo.png">
    <meta name="description" content="rh的博客">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0;">
    
    <link rel="preload" href="/assets/css/0.styles.74a02103.css" as="style"><link rel="preload" href="/assets/js/app.f8839a88.js" as="script"><link rel="preload" href="/assets/js/2.8d06e467.js" as="script"><link rel="preload" href="/assets/js/12.a9094538.js" as="script"><link rel="prefetch" href="/assets/js/10.75500dcd.js"><link rel="prefetch" href="/assets/js/11.592669c1.js"><link rel="prefetch" href="/assets/js/13.2cf414ec.js"><link rel="prefetch" href="/assets/js/14.d2737ceb.js"><link rel="prefetch" href="/assets/js/15.8eb8f805.js"><link rel="prefetch" href="/assets/js/16.820d5c80.js"><link rel="prefetch" href="/assets/js/17.801ecbcc.js"><link rel="prefetch" href="/assets/js/18.b2f69842.js"><link rel="prefetch" href="/assets/js/19.15396bbe.js"><link rel="prefetch" href="/assets/js/20.233b2644.js"><link rel="prefetch" href="/assets/js/21.858bfdd0.js"><link rel="prefetch" href="/assets/js/22.38ba5211.js"><link rel="prefetch" href="/assets/js/23.58fbdc70.js"><link rel="prefetch" href="/assets/js/24.15131ce6.js"><link rel="prefetch" href="/assets/js/25.7bce4e07.js"><link rel="prefetch" href="/assets/js/26.b37e74b8.js"><link rel="prefetch" href="/assets/js/27.64d94c4d.js"><link rel="prefetch" href="/assets/js/28.c78dfbd6.js"><link rel="prefetch" href="/assets/js/29.b576a40d.js"><link rel="prefetch" href="/assets/js/3.f9317427.js"><link rel="prefetch" href="/assets/js/30.29554d88.js"><link rel="prefetch" href="/assets/js/31.9af67186.js"><link rel="prefetch" href="/assets/js/32.d380b09a.js"><link rel="prefetch" href="/assets/js/33.eb0839b0.js"><link rel="prefetch" href="/assets/js/34.62b518b9.js"><link rel="prefetch" href="/assets/js/35.429a5bce.js"><link rel="prefetch" href="/assets/js/36.43c4d349.js"><link rel="prefetch" href="/assets/js/37.d6b42aa3.js"><link rel="prefetch" href="/assets/js/38.a7eec5a0.js"><link rel="prefetch" href="/assets/js/39.2f5a06ea.js"><link rel="prefetch" href="/assets/js/4.63a5e966.js"><link rel="prefetch" href="/assets/js/40.dc834d41.js"><link rel="prefetch" href="/assets/js/41.fcc4e1e8.js"><link rel="prefetch" href="/assets/js/42.e57f8aa8.js"><link rel="prefetch" href="/assets/js/43.15534ad1.js"><link rel="prefetch" href="/assets/js/44.eb90d815.js"><link rel="prefetch" href="/assets/js/45.6e206fc8.js"><link rel="prefetch" href="/assets/js/46.285350f5.js"><link rel="prefetch" href="/assets/js/47.cde65c12.js"><link rel="prefetch" href="/assets/js/48.1c870c67.js"><link rel="prefetch" href="/assets/js/49.2b6f4336.js"><link rel="prefetch" href="/assets/js/5.2c45f22c.js"><link rel="prefetch" href="/assets/js/50.1a667582.js"><link rel="prefetch" href="/assets/js/51.600bc042.js"><link rel="prefetch" href="/assets/js/52.2e105d94.js"><link rel="prefetch" href="/assets/js/53.fa0284c4.js"><link rel="prefetch" href="/assets/js/54.0b748f22.js"><link rel="prefetch" href="/assets/js/55.ee05dee1.js"><link rel="prefetch" href="/assets/js/56.21abdcc3.js"><link rel="prefetch" href="/assets/js/57.26ddbf76.js"><link rel="prefetch" href="/assets/js/58.91fd9800.js"><link rel="prefetch" href="/assets/js/59.6022db72.js"><link rel="prefetch" href="/assets/js/6.e9b45abe.js"><link rel="prefetch" href="/assets/js/60.1f2889ae.js"><link rel="prefetch" href="/assets/js/61.46040c7d.js"><link rel="prefetch" href="/assets/js/62.af7e9fcd.js"><link rel="prefetch" href="/assets/js/63.2fb355ca.js"><link rel="prefetch" href="/assets/js/64.99a87693.js"><link rel="prefetch" href="/assets/js/65.005ae6f4.js"><link rel="prefetch" href="/assets/js/66.12940877.js"><link rel="prefetch" href="/assets/js/67.b4a93190.js"><link rel="prefetch" href="/assets/js/68.c8d9d13c.js"><link rel="prefetch" href="/assets/js/69.158d7968.js"><link rel="prefetch" href="/assets/js/7.bbffe35f.js"><link rel="prefetch" href="/assets/js/70.4e4a3ae3.js"><link rel="prefetch" href="/assets/js/71.487c7568.js"><link rel="prefetch" href="/assets/js/72.e2a65bcb.js"><link rel="prefetch" href="/assets/js/8.bda61152.js"><link rel="prefetch" href="/assets/js/9.f87a0e7d.js">
    <link rel="stylesheet" href="/assets/css/0.styles.74a02103.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><img src="/img/logo.png" alt="个人主页" class="logo"> <span class="site-name can-hide">个人主页</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">
  主页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="博客文章" class="dropdown-title"><span class="title">博客文章</span> <span class="arrow down"></span></button> <button type="button" aria-label="博客文章" class="mobile-dropdown-title"><span class="title">博客文章</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/test/" class="nav-link">
  测试
</a></li><li class="dropdown-item"><!----> <a href="/frontend/" class="nav-link router-link-active">
  前端
</a></li><li class="dropdown-item"><!----> <a href="/linux/" class="nav-link">
  linux
</a></li><li class="dropdown-item"><!----> <a href="/other/" class="nav-link">
  杂文
</a></li><li class="dropdown-item"><!----> <a href="/node/" class="nav-link">
  Node
</a></li><li class="dropdown-item"><!----> <a href="/python/" class="nav-link">
  Python
</a></li></ul></div></div><div class="nav-item"><a href="/readlog.html" class="nav-link">
  阅读日志
</a></div><div class="nav-item"><a href="/about/" class="nav-link">
  关于
</a></div> <a href="https://github.com/JoeHR/vuePress-blog" target="_blank" rel="noopener noreferrer" class="repo-link">
    Github
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">
  主页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="博客文章" class="dropdown-title"><span class="title">博客文章</span> <span class="arrow down"></span></button> <button type="button" aria-label="博客文章" class="mobile-dropdown-title"><span class="title">博客文章</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/test/" class="nav-link">
  测试
</a></li><li class="dropdown-item"><!----> <a href="/frontend/" class="nav-link router-link-active">
  前端
</a></li><li class="dropdown-item"><!----> <a href="/linux/" class="nav-link">
  linux
</a></li><li class="dropdown-item"><!----> <a href="/other/" class="nav-link">
  杂文
</a></li><li class="dropdown-item"><!----> <a href="/node/" class="nav-link">
  Node
</a></li><li class="dropdown-item"><!----> <a href="/python/" class="nav-link">
  Python
</a></li></ul></div></div><div class="nav-item"><a href="/readlog.html" class="nav-link">
  阅读日志
</a></div><div class="nav-item"><a href="/about/" class="nav-link">
  关于
</a></div> <a href="https://github.com/JoeHR/vuePress-blog" target="_blank" rel="noopener noreferrer" class="repo-link">
    Github
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>javascript</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>css</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>React学习</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/frontend/react-react01.html" aria-current="page" class="active sidebar-link">react的相关知识点</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/frontend/react-react01.html#react-最新的生命周期是怎样的" class="sidebar-link">React 最新的生命周期是怎样的？</a></li><li class="sidebar-sub-header"><a href="/frontend/react-react01.html#react-的请求应该放在哪个生命周期中" class="sidebar-link">React 的请求应该放在哪个生命周期中？</a></li><li class="sidebar-sub-header"><a href="/frontend/react-react01.html#setstate-到底是异步还是同步" class="sidebar-link">setState 到底是异步还是同步？</a></li><li class="sidebar-sub-header"><a href="/frontend/react-react01.html#react-组件通信如何实现" class="sidebar-link">React 组件通信如何实现？</a></li><li class="sidebar-sub-header"><a href="/frontend/react-react01.html#react如何进行组件-逻辑-复用" class="sidebar-link">React如何进行组件/逻辑 复用</a></li><li class="sidebar-sub-header"><a href="/frontend/react-react01.html#mixin-hoc-高阶组件-render-props-、react-hooks-的优劣如何" class="sidebar-link">mixin,hoc(高阶组件),render Props 、react-hooks 的优劣如何？</a></li><li class="sidebar-sub-header"><a href="/frontend/react-react01.html#redux-的工作流程" class="sidebar-link">redux 的工作流程</a></li><li class="sidebar-sub-header"><a href="/frontend/react-react01.html#react-redux-是如何工作的" class="sidebar-link">react-redux 是如何工作的？</a></li><li class="sidebar-sub-header"><a href="/frontend/react-react01.html#redux-中如何进行异步操作" class="sidebar-link">redux 中如何进行异步操作</a></li></ul></li><li><a href="/frontend/react-style-jsx.html" class="sidebar-link">styled-jsx在 jsx 中得应用</a></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Vue学习</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>工具</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>进阶</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>性能</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>面试题</span> <span class="arrow right"></span></p> <!----></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h2 id="react-最新的生命周期是怎样的"><a href="#react-最新的生命周期是怎样的" class="header-anchor">#</a> React 最新的生命周期是怎样的？</h2> <p>React 16 之后有三个生命周期被废弃（但并未被删除）</p> <ul><li>componentWillMount</li> <li>componentWillReceiveProps</li> <li>componentWillUpdate</li></ul> <p>官方计划在 17 版本 完全删除这三个函数，只保留 UNSAVE_ 前缀的三个函数，目的是为了向下兼容，但是对于开发者而言应该尽量避免使用它们，而是使用新增的生命周期函数替代它们</p> <p>目前React 16.8 的生命周期分为 三个阶段，分别是挂载阶段、更新阶段、卸载阶段</p> <p>挂载阶段：</p> <table><thead><tr><th>生命周期函数</th> <th>描述或用途</th></tr></thead> <tbody><tr><td>constructor</td> <td>在 React 组件挂载之前，会调用它的构造函数;通常在react中，构造函数仅用于两种场景：1 -  通过 <code>this.state</code> 赋值对象来初始化内部 state;  2 - 为事件处理函数绑定实例</td></tr> <tr><td>static getDerivedStateFromProps</td> <td>静态方法，<code>static getDerivedStateFromProps(nextProps, prevState)</code> 会在调用 render  方法之前调用，并且在初始挂载及后续更新时都会被调用, 当我们接收到新的属性象去修改 state时，可以使用此方法</td></tr> <tr><td>render</td> <td>是class 组件中唯一必须实现的方法，返回需要渲染的东西，不应该包含其它的业务逻辑，可以返回原生的DOM、React组件、Fragment、Portals、字符串和数字、Boolean 和 null 等内容</td></tr> <tr><td>componentDidMount</td> <td>会在组件挂载后（插入Dom树中）立即调用，如果有依赖于Dom节点的初始化操作应该仿佛在这里。比如对canvas，svg的操作，服务器请求，订阅都可以写在这个里面，但是记得在componentWillUnmount中取消订阅。</td></tr> <tr><td>UNSAFE_componentWillMount()</td> <td>在挂载之前被调用。它在 <code>render()</code> 之前调用，因此在此方法中同步调用 <code>setState()</code> 不会触发额外渲染。</td></tr></tbody></table> <p>更新阶段</p> <table><thead><tr><th>static getDerivedStateFromProps</th> <th>此方法在更新个挂载阶段都可能会调用</th></tr></thead> <tbody><tr><td>shouldComponentUpdated</td> <td><code>shouldComponentUpdate(nextProps, nextState)</code> 有两个参数nextProps和nextState,表示新的属性和变化之后的state,返回一个布尔值，true表示会触发重新渲染，false表示不会触发重新渲染，默认返回true,我们通常利用此声明周期来优化 React 程序性能</td></tr> <tr><td>render</td> <td>更新阶段也会触发此渲染函数</td></tr> <tr><td>getSnapshotBeforeUpdate</td> <td><code>getSnapshotBeforeUpdate(prevProps, prevState)</code> 这个方法在 render 之后，componentDidUpdate 之前调用，有两个参数 prevProps和prevState，表示之前的属性和之前的state,这个函数有一个返回值，会作为第三个参数传给componentDidUpdate,如果你不想要返回值，可以返回null,此声明周期必须与 componentDidUpdate 搭配使用</td></tr> <tr><td>componentDidUpdate</td> <td><code>componentDidUpdate(prevProps, prevState, snapshot)</code>该方法在 getSnapshotBeforeUpdate 方法之后被调用，有三个参数prevProps，prevState,snapshot，表示之前的props ，之前的state,和snapshot。 第三个参数是 getSnapshotBeforeUpdate 返回的，如果触发某些回调函数时需要用到Dom 元素的状态，则将对比或计算的过程迁移至 getSnapshotBeforeUpdate ，然后在 componentDidUpdate 中统一触发回调或更新状态</td></tr> <tr><td>UNSAFE_componentWillUpdate</td> <td>当组件收到新的 props 或 state 时，会在 render 之前调用，使用此方法作为在更新发生之前执行准备更新的机会</td></tr> <tr><td>UNSAFE_componentWillReceiveProps</td> <td>会在已挂载的组件接收新的props 之前被调用。如果你需要更新状态以响应prop更改（如重置它）,你可以比较<code>this.props</code>和<code>nextProps</code>并在此方法中使用 <code>this.setState</code>执行 state转换</td></tr></tbody></table> <p>卸载阶段</p> <table><thead><tr><th>componentWillUnmount</th> <th>当我们的组件被卸载或者销毁了就会调用，我们可以在这个函数里去清楚一些定时器，取消网络请求，清理无效的DOM元素等垃圾清理工作</th></tr></thead> <tbody><tr><td></td> <td></td></tr></tbody></table> <p><img src="/assets/img/1589964630157.22bc90db.png" alt="1589964630157"></p> <blockquote><p>一个查看react生命周期的<a href="http://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/" target="_blank" rel="noopener noreferrer">网站<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p></blockquote> <h2 id="react-的请求应该放在哪个生命周期中"><a href="#react-的请求应该放在哪个生命周期中" class="header-anchor">#</a> React 的请求应该放在哪个生命周期中？</h2> <p>React 的异步请求到底应该放在哪个生命周期里，有人认为在 <code>componentWillMount</code> 中可以提前进行异步请求，避免白屏，其实这个观点是由有问题的</p> <p>由于Javascript 中异步事件的性质，当您启动API调用时，浏览器会在此期间返回执行其他工作。当React渲染一个组件时，它不会等待componentWillMount 它完成任何事情 - React 继续前进并继续 render, 没有办法“暂停”渲染以等待数据到达。</p> <p>而且在 <code>componentWillMount</code> 请求会有一系列潜在的问题，首先，在服务器渲染时，如果在componentWillMount 里获取数据， fetch data 会执行两次，一次在服务端一次在客户端吗，这造成了多余的请求，其次，在React 16 进行 React Fiber 重写后，<code>componentWillMount</code> 可能在一次渲染中多次调用</p> <p>目前官方推荐的异步请求是在 <code>componentDidMount</code> 中进行</p> <p>如果有特殊需求需要提前请求，也可以在特殊情况下在 constructor 中请求</p> <h2 id="setstate-到底是异步还是同步"><a href="#setstate-到底是异步还是同步" class="header-anchor">#</a> setState 到底是异步还是同步？</h2> <p>先给出答案：有时表现出异步，有时表现出同步</p> <ul><li><code>setState</code> 只在合成事件和钩子函数中是 异步的，在原生事件 和 setTimeout 中都是同步的</li> <li><code>setState</code> 的 &quot;异步&quot; 并不是说内部有异步代码实现，其实本身执行的过程和代码都是同步的，只是合成事件和钩子函数的调用顺序在更新之前，导致在合成事件和钩子函数中没法立马拿到更新后的值，形成了所谓的&quot;异步&quot;,当然可以通过第二个参数 <code>setState(partialState,callback)</code>的 <code>callback</code>拿到更新后的结果</li> <li><code>setState</code> 的批量更新优化也是建立在&quot;异步&quot;（合成事件，钩子函数）之上的，在原生事件和 setTimeout 中不会批量更新，在&quot;异步&quot;中如果对同一个值进行多次 <code>setState</code> , <code>setState</code> 的批量更新策略会对其进行覆盖，去最后一次的执行，如果是同事 <code>setState</code>多个不同的值，在更新时会对其进行合并批量更新。</li></ul> <h2 id="react-组件通信如何实现"><a href="#react-组件通信如何实现" class="header-anchor">#</a> React 组件通信如何实现？</h2> <p>React组件间通信方式</p> <ul><li>父组件向子组件通讯: 父组件可以向子组件 通过 传 props 的方式，向子组件进行通讯</li> <li>子组件向父组件通讯： props + 回调的方式，父组件向子组件传递 props 进行通信，此 props 为作用域为父组件自身的函数，子组件调用该函数，将子组件想要传递的信息，作为参数，传递到父组件的作用域中</li> <li>兄弟组件通讯：找到这两个兄弟组件共同的父节点，结合上面两种方式由父节点转发信息进行通讯</li> <li>跨层级通讯： <code>context</code> 设计目的是为了共享哪些对于一个组件树而言时“全局”的数据，例如当前认证的用户、主题或首选语言，对于跨越多层的全局数据通过 <code>context</code> 通讯再适合不过</li> <li>发布订阅模式： 发布者发布事件，订阅者监听事件并作出反应，我们可以通过引入 event模块进行通讯</li> <li>全局状态管理工具： 借助Redux 或者 Mobx 等全局状态管理工具进行通信，这种工具会维护一个全局状态中心 Store，并根据不同的事件产生新的状态</li></ul> <p><img src="/assets/img/2ccb1b43c7392d5a0594668fdcbec4de.2ccb1b43.png" alt="2019-07-31-18-38-37"></p> <h2 id="react如何进行组件-逻辑-复用"><a href="#react如何进行组件-逻辑-复用" class="header-anchor">#</a> React如何进行组件/逻辑 复用</h2> <p>抛开已经被官方弃用的Mixin,组件抽象的技术目前有三种比较主流</p> <ul><li>高阶组件
<ul><li>属性代理</li> <li>反向继承</li></ul></li> <li>渲染属性</li> <li>react-hooks</li></ul> <h2 id="mixin-hoc-高阶组件-render-props-、react-hooks-的优劣如何"><a href="#mixin-hoc-高阶组件-render-props-、react-hooks-的优劣如何" class="header-anchor">#</a> mixin,hoc(高阶组件),render Props 、react-hooks 的优劣如何？</h2> <p>mixin 的缺陷：</p> <ul><li>组件与 mixin 之间存在隐式依赖（Mixin 经常依赖组件的特定方法，但在定义组件时并不知道这种依赖关系）</li> <li>多个 Mixin 之间可能产生冲突（比如定义了相同的state）</li> <li>Mixin 倾向于增加更多状态，这降低了应用的可预测性,导致复杂度剧增</li> <li>隐式依赖导致依赖关系不透明，维护成本和理解成本迅速攀升
<ul><li>难以快速理解组件行为，需要全盘了解所有依赖 Mixin 的扩展行为，及其之间的相互影响</li> <li>组件自身的方法和state 字段不敢轻易删改，因为难以确定有没有 Mixin 依赖他</li> <li>Mixin 也难以维护，因为 Mixin 逻辑最后会被合并到一期，很难搞清楚一个 Mixin 的输入输出</li></ul></li></ul> <p>Hoc 相比 Mixin 的优势</p> <ul><li>HOC 通过外层组件通过 props 影响内层组件的状态，而不是直接改变其 state，不存在从图和互相干扰，这就降低了耦合度</li> <li>不同于 Mixin 的打平 + 合并，HOC 具有天然的层级结构（组件树结构）,这又降低了复杂度</li></ul> <p>HOC 的缺陷</p> <ul><li>扩展性限制：Hoc 无法从外部访问子组件的state ，因此无法通过 shouldComponentUpdated 过滤掉不必要的更新，React在 支持 ES6 class 之后提供了 React.PureComponent 来解决这个问题</li> <li>Ref 传递问题：Ref 被隔断，后来的 React.forwardRef 来解决这个问题</li> <li>Wrapper Hell: Hoc 可能出现多层包裹组件的情况，多层抽象同样增加了复杂度和理解成本</li> <li>命名冲突：如果高阶组件多次嵌套，没有使用命名空间的话会产生冲突，然后覆盖老属性</li> <li>不可见性：Hoc 相当于在原有组件外层再包装一个组件，你压根不知道外层的保障是啥，对于你式黑盒</li></ul> <p>Render Props 的优点</p> <ul><li>上述HOC 的缺点 Render Props 都可以解决</li></ul> <p>Render Props 的缺陷</p> <ul><li>使用繁琐: Hoc 使用只需要借助装饰器语法通常一行代码就可以进行复用，Render Props 无法左到如此简单</li> <li>嵌套过深： Render Props 虽然拜托了组件多层嵌套的问题，但是转化为了函数回调的嵌套</li></ul> <p>React Hooks 优点</p> <ul><li>简洁： React Hooks 解决了 Hoc 和 Render Props 的嵌套问题，更加简洁</li> <li>解耦： React Hooks 可以更方便的把UI 和状态分离，做到更彻底的解耦</li> <li>组合： Hooks 中可以引用另外的Hooks 形成新的 Hooks ，组合变化万千</li> <li>函数友好： React Hooks 为函数组件而生，从而解决了类组件的几大问题：
<ul><li>this 指向容易错误</li> <li>分割在不同生命周期中的逻辑使的代码难以理解和维护</li> <li>代码复用成本高（高阶组件容易使代码量剧增）</li></ul></li></ul> <p>React Hooks 的缺陷</p> <ul><li>额外的学习成本（Functional Component 与 Class Component 之间的困惑）</li> <li>写法上有限制（不能出现在条件 和 循环中），并且写法限制增加了重构成本</li> <li>破坏了 PureComponent、React.memo 浅比较的性能优化效果（为了取最新的Props 和 State,每次 render() 都要重新创建事件处理函数）</li> <li>在闭包场景可能会引用到旧的 state、props 值</li> <li>内部实现上不直观（依赖一份可变的全局状态，不再那么'纯'）</li> <li>React.memo 并不能完全替代 shouldComponentUpdate (因为拿不到 state change,只针对 props change)</li></ul> <h2 id="redux-的工作流程"><a href="#redux-的工作流程" class="header-anchor">#</a> redux 的工作流程</h2> <p>首先，我们看下几个核心概念：</p> <ul><li>Store: 保存数据的地方，你可以把它看成一个容器，整个应用只能有一个Store</li> <li>State: Store 对象包含所有数据，如果想得到某个时刻的数据，就要对 Store 生成快照，这一时刻的数据集合，就叫做 State</li> <li>Action: State 的变化，会导致 View 的变化。但是，用户接触不到 State,只能接触到View。所以，State 的变化必须使View 导致的。Action 就是 View 发出的通知，表示 State 应该要发生变化了。</li> <li>Action Creator: View 要发送多少种消息，就会有多少种Action.如果都手写，会很麻烦，所以我们顶一个一个函数来生成Action,这个函数就叫 Action Creator.</li> <li>Reducer: Store 收到 Action 之后，必须给出一个新的State,这样View 才会发生变化。这种 State 的计算过程就叫做 Reducer。 Reducer 是一个函数，它接受 Action 和 当前 State 作为参数，返回一个新的State。</li> <li>dispatch: 是 View 发出 Action 的唯一方法</li></ul> <p>然后我们过下整个工作流程：</p> <p>1、首先，用户（通过View）发出 Action,发出方式就用到了 dispatch 方法
2、然后，Store 自动调用 Reducer,并且传入两个参数: 当前State 和 收到的Action,Reducer 会返回新的 State
3、State 一旦有变化，Store 就会调用监听函数，来更新View</p> <p>到这儿为止，一次用户交互流程结束。可以看到，在整个流程中数据都是单向流动的，这种方式保证了流程的清晰。</p> <p><img src="/assets/img/0ab0e624522ae6efef415b53cb923bf7.0ab0e624.png" alt="2019-08-01-17-29-20"></p> <h2 id="react-redux-是如何工作的"><a href="#react-redux-是如何工作的" class="header-anchor">#</a> react-redux 是如何工作的？</h2> <ul><li><p>Provider: Provider 的作用是从最外部封装了整个应用，并向connect 模块传递 store</p></li> <li><p>connect: 负责链接 React 和 Redux</p> <ul><li>获取state: connect 通过 context 获取Provider 中的store,通过 store.getState() 获取整个store tree 上所有state</li> <li>包装原组件： 将state 和 action 通过 props 的方式传入到原组件内部 wrapWithConnect 返回一个 ReactComponent 对象Connect,
Connect 重新render 外部传入的原组件 WrapperedComponent,并把 connect 中传入的mapStateToProps，mapDispatchToProps 与组件上原有的props合并后，通过属性的方式传给 WrappedComponent</li> <li>监听 store tree 变化： connect 缓存了 store tree 中state的状态，通过当前 state 状态和变更前state 状态进行比较，从而确定是否调用<code>this.setState()</code>方法触发 Connect 及其子组件的重新渲染</li></ul> <p><img src="/assets/img/710f0a9f0a8e6a320f55fa0ca795a3c7.710f0a9f.png" alt="2019-08-01-22-21-51"></p></li></ul> <h2 id="redux-中如何进行异步操作"><a href="#redux-中如何进行异步操作" class="header-anchor">#</a> redux 中如何进行异步操作</h2> <p>当然我们可以在  <code>componentDidMount</code> 中直接进行请求无需借助redux</p> <p>但在一定规模的项目中，上述方法很难进行异步流的管理，通常情况下我们会借助redux 的异步中间件进行异步处理</p> <p>redux 异步流中间件其实有很多，但是档下主流的异步中间件只有两种redux-thunk、redux-saga,当然redux-observable 可能也有资格占据一席之地，其余的异步中间件不管是社区活跃度还是npm 下载了都比较差了</p></div> <footer class="page-edit"><!----> <div class="last-updated"><span class="prefix">最后更新时间:</span> <span class="time">2/21/2022, 3:29:09 PM</span></div></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/frontend/css-css基础.html" class="prev">
        css基础
      </a></span> <span class="next"><a href="/frontend/react-style-jsx.html">
        styled-jsx在 jsx 中得应用
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"><!----></div></div>
    <script src="/assets/js/app.f8839a88.js" defer></script><script src="/assets/js/2.8d06e467.js" defer></script><script src="/assets/js/12.a9094538.js" defer></script>
  </body>
</html>
